<!DOCTYPE html>
<html>
<head>
  <title>Urban Combat TPS - Village Battle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: black; 
      font-family: 'Arial', sans-serif; 
      cursor: crosshair;
      touch-action: none; /* Prevent default touch actions */
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      #instructions { 
        font-size: 12px; 
        padding: 3px;
      }
      
      #hud { 
        bottom: 10px; 
        left: 10px; 
        padding: 5px;
        font-size: 12px;
      }
      
      #health-bar-container { 
        width: 100px; 
        height: 15px; 
      }
      
      #weapon-display { 
        font-size: 14px; 
      }
      
      #ammo-display { 
        font-size: 12px; 
      }
      
      #score-display { 
        font-size: 14px; 
      }
      
      #combo-display { 
        font-size: 12px; 
      }
      
      #enemy-counter {
        font-size: 14px;
        right: 10px;
        top: 5px;
      }
      
      #medikit-counter {
        font-size: 14px;
        right: 10px;
        top: 30px;
      }
      
      #minimap-container {
        width: 100px;
        height: 100px;
        bottom: 10px;
        right: 10px;
      }
      
      #upgrade-shop {
        width: 90%;
        max-height: 70%;
      }
    }
    
    /* Menu Screen Styles */
    #menu-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('https://z-cdn-media.chatglm.cn/files/7091fe5f-1fa2-46f9-ac55-b8bb76b39660.png?auth_key=1872017979-36f4b8ed4bfe4082849cb5b2bc701b91-0-3fd47c606dfd5c32c635cb7ff530a692') no-repeat center center;
      background-size: cover;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 0.5s ease-out;
    }
    
    #menu-title {
      font-size: 48px;
      color: white;
      text-shadow: 3px 3px 0 #000, 0 0 20px rgba(255, 107, 53, 0.8);
      margin-bottom: 30px;
      font-family: 'Courier New', monospace;
      letter-spacing: 2px;
      animation: pulse 2s infinite;
    }
    
    @media (max-width: 768px) {
      #menu-title {
        font-size: 32px;
      }
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    #story-text {
      max-width: 600px;
      padding: 20px;
      background-color: rgba(0, 0, 0, 0.8);
      border: 2px solid #ff6b35;
      border-radius: 10px;
      color: #ffffff;
      font-size: 16px;
      line-height: 1.6;
      margin-bottom: 30px;
      text-align: center;
      box-shadow: 0 0 20px rgba(255, 107, 53, 0.5);
    }
    
    @media (max-width: 768px) {
      #story-text {
        max-width: 90%;
        padding: 15px;
        font-size: 14px;
      }
    }
    
    #start-button {
      padding: 15px 40px;
      font-size: 24px;
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      color: white;
      font-weight: bold;
    }
    
    @media (max-width: 768px) {
      #start-button {
        padding: 12px 30px;
        font-size: 20px;
      }
    }
    
    #start-button:hover {
      background: linear-gradient(45deg, #f7931e, #ff6b35);
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }
    
    /* Game Screen Styles */
    #game-screen {
      display: none;
    }
    
    #crosshair { 
      position: absolute; 
      top: 50%; 
      left: 50%; 
      color: white; 
      font-size: 30px; 
      transform: translate(-50%, -50%); 
      pointer-events: none; 
      z-index: 10; 
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
      transition: opacity 0.2s ease;
    }
    
    #instructions { 
      position: absolute; 
      top: 10px; 
      width: 100%; 
      text-align: center; 
      color: white; 
      z-index: 100; 
      background: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border-radius: 5px;
    }
    
    #hud { 
      position: absolute; 
      bottom: 20px; 
      left: 20px; 
      color: white; 
      z-index: 100; 
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }
    
    #health-bar-container { 
      width: 200px; 
      height: 20px; 
      border: 2px solid white; 
      background-color: #555; 
      border-radius: 3px;
    }
    
    #health-bar { 
      width: 100%; 
      height: 100%; 
      background-color: #4CAF50; 
      transition: width 0.3s ease, background-color 0.3s ease;
    }
    
    #weapon-display { 
      margin-top: 10px; 
      font-size: 20px; 
    }
    
    #ammo-display { 
      margin-top: 5px; 
      font-size: 16px; 
      color: #cccccc;
    }
    
    #score-display { 
      margin-top: 10px; 
      font-size: 20px; 
      color: gold; 
    }
    
    #combo-display { 
      margin-top: 5px; 
      font-size: 16px; 
      color: orange; 
    }
    
    #game-over { 
      position: absolute; 
      top: 50%; 
      left: 50%; 
      color: red; 
      font-size: 50px; 
      font-weight: bold; 
      transform: translate(-50%, -50%); 
      display: none; 
      z-index: 200; 
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
    }
    
    @media (max-width: 768px) {
      #game-over {
        font-size: 36px;
      }
    }
    
    #final-score { 
      position: absolute; 
      top: 60%; 
      left: 50%; 
      color: white; 
      font-size: 30px; 
      transform: translate(-50%, -50%); 
      display: none; 
      z-index: 200; 
    }
    
    @media (max-width: 768px) {
      #final-score {
        font-size: 24px;
      }
    }
    
    .hit-popup { 
      position: absolute; 
      color: yellow; 
      font-size: 24px; 
      font-weight: bold; 
      pointer-events: none; 
      animation: fadeOut 1s forwards; 
      z-index: 150; 
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
    }
    
    @keyframes fadeOut {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-30px); }
    }
    
    /* Story Display */
    #story-display {
      position: absolute;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      max-width: 600px;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.8);
      border: 2px solid #ff6b35;
      border-radius: 10px;
      color: #ffffff;
      font-size: 14px;
      line-height: 1.5;
      text-align: center;
      display: none;
      z-index: 100;
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.5);
    }
    
    @media (max-width: 768px) {
      #story-display {
        top: 80px;
        max-width: 90%;
        font-size: 12px;
      }
    }
    
    /* Boss Health Bar */
    #boss-health-container {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      height: 30px;
      border: 3px solid #ff0000;
      background-color: #330000;
      display: none;
      z-index: 100;
      border-radius: 5px;
    }
    
    @media (max-width: 768px) {
      #boss-health-container {
        width: 80%;
        height: 25px;
        top: 60px;
      }
    }
    
    #boss-health {
      width: 100%;
      height: 100%;
      background-color: #ff0000;
      transition: width 0.3s ease;
    }
    
    #boss-name {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      color: #ff0000;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000;
      display: none;
      z-index: 100;
    }
    
    @media (max-width: 768px) {
      #boss-name {
        font-size: 20px;
        top: 35px;
      }
    }
    
    /* Enemy Counter */
    #enemy-counter {
      position: absolute;
      top: 10px;
      right: 20px;
      color: white;
      font-size: 18px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 5px;
    }
    
    /* Medikit Counter */
    #medikit-counter {
      position: absolute;
      top: 40px;
      right: 20px;
      color: #00ff00;
      font-size: 18px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 5px;
    }
    
    /* Loading Screen */
    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      color: white;
      font-size: 24px;
    }
    
    /* Minimap */
    #minimap-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 200px;
      border: 2px solid #ffffff;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 5px;
      z-index: 100;
    }
    
    #minimap {
      width: 100%;
      height: 100%;
      border-radius: 3px;
    }
    
    /* Weapon Upgrade Shop */
    #upgrade-shop {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 600px;
      max-height: 500px;
      background-color: rgba(0, 0, 0, 0.9);
      border: 2px solid #ff6b35;
      border-radius: 10px;
      color: white;
      padding: 20px;
      display: none;
      z-index: 300;
      overflow-y: auto;
    }
    
    #upgrade-shop h2 {
      text-align: center;
      color: #ff6b35;
      margin-bottom: 20px;
    }
    
    .upgrade-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      margin-bottom: 10px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    
    .upgrade-item:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    .upgrade-button {
      padding: 5px 15px;
      background-color: #ff6b35;
      border: none;
      border-radius: 5px;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .upgrade-button:hover {
      background-color: #f7931e;
    }
    
    .upgrade-button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }
    
    #close-shop {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
    }
    
    /* Wave Display */
    #wave-display {
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      color: #ff6b35;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000;
      display: none;
      z-index: 100;
    }
    
    @media (max-width: 768px) {
      #wave-display {
        font-size: 20px;
        top: 50px;
      }
    }

    /* --- PAUSE MENU --- */
    #pause-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      display: none; /* Hidden by default */
      justify-content: center;
      align-items: center;
      z-index: 2001; /* On top of everything */
      flex-direction: column;
    }
    
    #pause-menu h2 {
      color: #ff6b35;
      font-size: 48px;
      margin-bottom: 30px;
      text-shadow: 2px 2px 0 #000;
    }
    
    @media (max-width: 768px) {
      #pause-menu h2 {
        font-size: 36px;
      }
    }
    
    .pause-menu-button {
      padding: 15px 30px;
      margin: 10px;
      font-size: 20px;
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      color: white;
      font-weight: bold;
      min-width: 200px;
    }
    
    @media (max-width: 768px) {
      .pause-menu-button {
        padding: 12px 25px;
        font-size: 18px;
        min-width: 180px;
      }
    }
    
    .pause-menu-button:hover {
      background: linear-gradient(45deg, #f7931e, #ff6b35);
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    /* --- SCOPE DOT --- */
    #scope-dot {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 4px;
      height: 4px;
      background-color: red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 11; 
      display: none; 
      box-shadow: 0 0 5px 1px rgba(255, 0, 0, 0.7);
    }

    /* --- WEAPON CONTAINER & IMAGES --- */
    #weapon-container {
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        pointer-events: none;
        z-index: 5;
        transition: transform 0.05s ease-out, opacity 0.2s ease;
    }

    /* --- Individual Weapon Image Styles --- */
    .weapon-img {
        position: absolute;
        bottom: 150px;
        left: 50%;
        transform: translateX(-50%);
        pointer-events: none;
        display: none; /* Hidden by default */
    }

    #pistol-img {
        width: 400px;
        bottom: -10px;
    }
    
    @media (max-width: 768px) {
      #pistol-img {
        width: 250px;
      }
    }

    #shotgun-img {
        width: 500px;
        bottom: -5px;
    }
    
    @media (max-width: 768px) {
      #shotgun-img {
        width: 320px;
      }
    }

    #rifle-img {
        width: 500px;
        bottom: -5px;
    }
    
    @media (max-width: 768px) {
      #rifle-img {
        width: 280px;
      }
    }

    #rocket-launcher-img {
        width: 500px;
        bottom: -5px;
    }
    
    @media (max-width: 768px) {
      #rocket-launcher-img {
        width: 350px;
      }
    }
    
    #flamethrower-img {
        width: 500px;
        bottom: -5px;
    }
    
    @media (max-width: 768px) {
      #flamethrower-img {
        width: 300px;
      }
    }

    /* --- 2D MUZZLE FLASH --- */
    #muzzle-flash {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 120px;
      height: 120px;
      display: none; /* Hidden by default */
      pointer-events: none; /* Ensures it doesn't block clicks */
      z-index: 20; /* Appear on top of the gun */
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      filter: brightness(1.8) contrast(1.5) saturate(1.5);
      mix-blend-mode: screen;
    }
    
    /* --- MUZZLE FLASH PULSE EFFECT --- */
    @keyframes muzzlePulse {
      0% { 
        transform: translate(-50%, -50%) scale(0.8); 
        opacity: 0.9;
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.2); 
        opacity: 1;
      }
      100% { 
        transform: translate(-50%, -50%) scale(0.9); 
        opacity: 0.8;
      }
    }
    
    .muzzle-active {
      animation: muzzlePulse 0.1s ease-out;
    }
    
    /* --- MOBILE CONTROLS --- */
    #mobile-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 90;
      display: none; /* Hidden by default, shown on mobile */
    }
    
    @media (max-width: 768px) {
      #mobile-controls {
        display: block;
      }
    }
    
    #joystick-container {
      position: absolute;
      bottom: 80px;
      left: 80px;
      width: 120px;
      height: 120px;
      pointer-events: auto;
    }
    
    #joystick-base {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.5);
    }
    
    #joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      background: rgba(255, 107, 53, 0.7);
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.8);
      top: 35px;
      left: 35px;
    }
    
    #fire-button {
      position: absolute;
      bottom: 100px;
      right: 50px;
      width: 80px;
      height: 80px;
      background: rgba(255, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      pointer-events: auto;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 14px;
      font-weight: bold;
    }
    
    #action-buttons {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: auto;
    }
    
    .action-button {
      width: 60px;
      height: 40px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 5px;
      color: white;
      font-size: 12px;
      font-weight: bold;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #weapon-selector {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 5px;
      pointer-events: auto;
    }
    
    .weapon-button {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 5px;
      color: white;
      font-size: 12px;
      font-weight: bold;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .weapon-button.active {
      background: rgba(255, 107, 53, 0.7);
      border-color: rgba(255, 255, 255, 0.8);
    }
    
    #pause-button {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 40px;
      height: 40px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 5px;
      color: white;
      font-size: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: auto;
    }
    
    /* Touch area for looking around */
    #touch-area {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
    }
  </style>
</head>
<body>

<!-- Menu Screen -->
<div id="menu-screen">
  <h1 id="menu-title">VILLAGE COMBAT</h1>
  <div id="story-text">
    <p><strong>CHAPTER 1: THE PEACEFUL VILLAGE</strong></p>
    <p>In the quiet village of Oakhaven, life was peaceful. The villagers lived in harmony with nature, farming the land and trading with neighboring settlements. But darkness was stirring in the mountains beyond...</p>
    
    <p><strong>CHAPTER 2: SHADOWS FALL</strong></p>
    <p>The Demon King Malphas, once banished to the underworld, has found a way back to the mortal realm. With his army of demonic minions, he seeks to corrupt the land and claim Oakhaven as his new kingdom of shadows.</p>
    
    <p><strong>CHAPTER 3: THE LAST STAND</strong></p>
    <p>You are the village's last hope. Armed with your grandfather's vintage weapons and medical supplies, you must defend Oakhaven against the demonic invasion. The fate of the village rests in your hands...</p>
    
    <p><em>Press START to begin your mission...</em></p>
  </div>
  <button id="start-button">START MISSION</button>
</div>

<!-- Game Screen -->
<div id="game-screen">
  <div id="instructions">WASD to move, Mouse to look, Left-Click to shoot, Right-Click to scope (Rifle), 1-5 to switch weapons, E to use medikit, B to open shop, Esc to pause</div>
  <div id="crosshair">+</div>
  <div id="scope-dot"></div>
  <div id="hud">
    <div>Health</div>
    <div id="health-bar-container"><div id="health-bar"></div></div>
    <div id="weapon-display">Weapon: Pistol</div>
    <div id="ammo-display">Ammo: ∞</div>
    <div id="score-display">Score: 0</div>
    <div id="combo-display">Combo: x1</div>
  </div>
  <div id="enemy-counter">Enemies: 0</div>
  <div id="medikit-counter">Medikits: 0</div>
  <div id="story-display"></div>
  <div id="game-over">GAME OVER</div>
  <div id="final-score">Final Score: 0</div>
  <div id="wave-display">WAVE 1</div>
</div>

<!-- Boss Elements -->
<div id="boss-name">DEMON KING</div>
<div id="boss-health-container"><div id="boss-health"></div></div>

<!-- Loading Screen -->
<div id="loading-screen">LOADING...</div>

<!-- Minimap -->
<div id="minimap-container">
  <canvas id="minimap"></canvas>
</div>

<!-- Weapon Upgrade Shop -->
<div id="upgrade-shop">
  <button id="close-shop">✕</button>
  <h2>WEAPON UPGRADES</h2>
  <div id="upgrade-list"></div>
</div>

<!-- WEAPON CONTAINER -->
<div id="weapon-container">
  <!-- IMPORTANT: Replace the src with your local image paths -->
  <img id="pistol-img" class="weapon-img" src="image/41061a1c435b0001aaae0378bdeb0608.png" alt="Pistol">
  <img id="shotgun-img" class="weapon-img" src="image/67c34fa8113026cc50555bfee180eb88.png" alt="Shotgun">
  <img id="rifle-img" class="weapon-img" src="image/f9c81650038c6074e1b445d40e985fe4.png" alt="Rifle">
  <img id="rocket-launcher-img" class="weapon-img" src="image/a813ce1a889ad048151524823123242f.png" alt="M4">
  <img id="flamethrower-img" class="weapon-img" src="image/78675f1ee449be75704076baaf3c20d1.png" alt="scelar">

  <!-- MUZZLE FLASH IMAGE -->
  <img id="muzzle-flash" src="image/5888c6febc2fc2ef3a1860d5.png">
</div>

<!-- Pause Menu -->
<div id="pause-menu">
  <h2>PAUSED</h2>
  <button id="resume-button" class="pause-menu-button">RESUME</button>
  <button id="new-game-button" class="pause-menu-button">NEW GAME</button>
  <button id="quit-button" class="pause-menu-button">QUIT</button>
</div>

<!-- Mobile Controls -->
<div id="mobile-controls">
  <div id="touch-area"></div>
  
  <div id="joystick-container">
    <div id="joystick-base"></div>
    <div id="joystick-stick"></div>
  </div>
  
  <div id="fire-button">FIRE</div>
  
  <div id="action-buttons">
    <div id="medikit-button" class="action-button">MED</div>
    <div id="reload-button" class="action-button">REL</div>
    <div id="shop-button" class="action-button">SHOP</div>
  </div>
  
  <div id="weapon-selector">
    <div class="weapon-button active" data-weapon="0">1</div>
    <div class="weapon-button" data-weapon="1">2</div>
    <div class="weapon-button" data-weapon="2">3</div>
    <div class="weapon-button" data-weapon="3">4</div>
    <div class="weapon-button" data-weapon="4">5</div>
  </div>
  
  <div id="pause-button">⏸</div>
</div>

<script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

// --- MENU SCREEN LOGIC ---
const menuScreen = document.getElementById('menu-screen');
const gameScreen = document.getElementById('game-screen');
const startButton = document.getElementById('start-button');
const loadingScreen = document.getElementById('loading-screen');
const storyDisplay = document.getElementById('story-display');
const waveDisplay = document.getElementById('wave-display');
const muzzleFlashElement = document.getElementById('muzzle-flash');
const weaponContainer = document.getElementById('weapon-container'); // Get weapon container
const scopeDot = document.getElementById('scope-dot');
const crosshair = document.getElementById('crosshair');

// --- PAUSE MENU ELEMENTS ---
const pauseMenu = document.getElementById('pause-menu');
const resumeButton = document.getElementById('resume-button');
const newGameButton = document.getElementById('new-game-button');
const quitButton = document.getElementById('quit-button');

// --- MOBILE CONTROLS ---
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
const mobileControls = document.getElementById('mobile-controls');
const joystickContainer = document.getElementById('joystick-container');
const joystickBase = document.getElementById('joystick-base');
const joystickStick = document.getElementById('joystick-stick');
const fireButton = document.getElementById('fire-button');
const medikitButton = document.getElementById('medikit-button');
const reloadButton = document.getElementById('reload-button');
const shopButton = document.getElementById('shop-button');
const weaponButtons = document.querySelectorAll('.weapon-button');
const pauseButton = document.getElementById('pause-button');
const touchArea = document.getElementById('touch-area');

// Mobile control variables
let joystickActive = false;
let joystickPosition = { x: 0, y: 0 };
let touchStartX = 0;
let touchStartY = 0;
let touchDeltaX = 0;
let touchDeltaY = 0;
let fireButtonPressed = false;

// Get all weapon image elements
const pistolImg = document.getElementById('pistol-img');
const shotgunImg = document.getElementById('shotgun-img');
const rifleImg = document.getElementById('rifle-img');
const rocketLauncherImg = document.getElementById('rocket-launcher-img');
const flamethrowerImg = document.getElementById('flamethrower-img');

const weaponImages = [pistolImg, shotgunImg, rifleImg, rocketLauncherImg, flamethrowerImg];

// Weapon-specific muzzle flash positions (precise barrel end positions)
const muzzleFlashPositions = {
  pistol: { 
    xPercent: 92, 
    yPercent: 48, 
    scale: 0.6,
    offsetX: 0,
    offsetY: 0
  },
  shotgun: { 
    xPercent: 94, 
    yPercent: 52, 
    scale: 1.0,
    offsetX: 0,
    offsetY: 5
  },
  rifle: { 
    xPercent: 96, 
    yPercent: 49, 
    scale: 0.8,
    offsetX: 0,
    offsetY: 0
  },
  rocketLauncher: { 
    xPercent: 97, 
    yPercent: 50, 
    scale: 1.3,
    offsetX: 0,
    offsetY: 0
  },
  flamethrower: { 
    xPercent: 95, 
    yPercent: 45, 
    scale: 0.9,
    offsetX: 0,
    offsetY: -5
  }
};

// --- MOBILE CONTROLS SETUP ---
if (isMobile) {
  // Update instructions for mobile
  document.getElementById('instructions').textContent = 'Use joystick to move, drag screen to look, tap FIRE to shoot, tap buttons for actions';
  
  // Set up joystick controls
  joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
  joystickContainer.addEventListener('touchmove', handleJoystickMove, { passive: false });
  joystickContainer.addEventListener('touchend', handleJoystickEnd, { passive: false });
  
  // Set up fire button
  fireButton.addEventListener('touchstart', handleFireStart, { passive: false });
  fireButton.addEventListener('touchend', handleFireEnd, { passive: false });
  
  // Set up action buttons
  medikitButton.addEventListener('touchstart', () => { useMedikit(); }, { passive: false });
  reloadButton.addEventListener('touchstart', () => { reloadWeapon(); }, { passive: false });
  shopButton.addEventListener('touchstart', () => { if (!isPaused) openUpgradeShop(); }, { passive: false });
  pauseButton.addEventListener('touchstart', togglePauseMenu, { passive: false });
  
  // Set up weapon selector
  weaponButtons.forEach(button => {
    button.addEventListener('touchstart', () => {
      const weaponIndex = parseInt(button.getAttribute('data-weapon'));
      switchWeapon(weaponIndex);
    }, { passive: false });
  });
  
  // Set up touch area for looking around
  touchArea.addEventListener('touchstart', handleTouchStart, { passive: false });
  touchArea.addEventListener('touchmove', handleTouchMove, { passive: false });
  touchArea.addEventListener('touchend', handleTouchEnd, { passive: false });
}

function handleJoystickStart(event) {
  event.preventDefault();
  joystickActive = true;
  const touch = event.touches[0];
  const rect = joystickContainer.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  
  joystickPosition.x = touch.clientX - centerX;
  joystickPosition.y = touch.clientY - centerY;
  
  // Limit joystick position to the base
  const distance = Math.sqrt(joystickPosition.x ** 2 + joystickPosition.y ** 2);
  const maxDistance = rect.width / 2 - 25; // 25 is half the stick width
  
  if (distance > maxDistance) {
    joystickPosition.x = (joystickPosition.x / distance) * maxDistance;
    joystickPosition.y = (joystickPosition.y / distance) * maxDistance;
  }
  
  // Update stick position
  joystickStick.style.transform = `translate(${joystickPosition.x}px, ${joystickPosition.y}px)`;
}

function handleJoystickMove(event) {
  event.preventDefault();
  if (!joystickActive) return;
  
  const touch = event.touches[0];
  const rect = joystickContainer.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  
  joystickPosition.x = touch.clientX - centerX;
  joystickPosition.y = touch.clientY - centerY;
  
  // Limit joystick position to the base
  const distance = Math.sqrt(joystickPosition.x ** 2 + joystickPosition.y ** 2);
  const maxDistance = rect.width / 2 - 25; // 25 is half the stick width
  
  if (distance > maxDistance) {
    joystickPosition.x = (joystickPosition.x / distance) * maxDistance;
    joystickPosition.y = (joystickPosition.y / distance) * maxDistance;
  }
  
  // Update stick position
  joystickStick.style.transform = `translate(${joystickPosition.x}px, ${joystickPosition.y}px)`;
}

function handleJoystickEnd(event) {
  event.preventDefault();
  joystickActive = false;
  joystickPosition = { x: 0, y: 0 };
  joystickStick.style.transform = 'translate(0, 0)';
}

function handleFireStart(event) {
  event.preventDefault();
  fireButtonPressed = true;
  fireButton.style.background = 'rgba(255, 0, 0, 0.8)';
}

function handleFireEnd(event) {
  event.preventDefault();
  fireButtonPressed = false;
  fireButton.style.background = 'rgba(255, 0, 0, 0.5)';
}

function handleTouchStart(event) {
  event.preventDefault();
  const touch = event.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
  touchDeltaX = 0;
  touchDeltaY = 0;
}

function handleTouchMove(event) {
  event.preventDefault();
  const touch = event.touches[0];
  touchDeltaX = touch.clientX - touchStartX;
  touchDeltaY = touch.clientY - touchStartY;
}

function handleTouchEnd(event) {
  event.preventDefault();
  touchDeltaX = 0;
  touchDeltaY = 0;
}

function switchWeapon(index) {
  currentWeaponIndex = index;
  updateWeaponDisplay();
  switchWeaponUI(currentWeaponIndex);
  
  // Update active button
  weaponButtons.forEach(button => {
    button.classList.remove('active');
    if (parseInt(button.getAttribute('data-weapon')) === index) {
      button.classList.add('active');
    }
  });
}

startButton.addEventListener('click', () => {
  menuScreen.style.opacity = '0';
  setTimeout(() => {
    menuScreen.style.display = 'none';
    gameScreen.style.display = 'block';
    loadingScreen.style.display = 'flex';
    initGame();
  }, 500);
});

// --- GAME INITIALIZATION ---
function initGame() {
  // --- SCENE SETUP ---
  const scene = new THREE.Scene(); 
  scene.background = new THREE.Color(0x87ceeb); 
  scene.fog = new THREE.FogExp2(0x87ceeb, 0.001);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); 
  camera.position.set(0, 2.5, 30);
  
  // Enhanced renderer settings
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); 
  renderer.setSize(window.innerWidth, window.innerHeight); 
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true; 
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.shadowMap.autoUpdate = true;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.5;
  renderer.physicallyCorrectLights = true;
  document.body.appendChild(renderer.domElement);

  // --- ADVANCED LIGHTING ---
  const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
  sunLight.position.set(50, 100, 50);
  sunLight.castShadow = true;
  sunLight.shadow.camera.left = -100;
  sunLight.shadow.camera.right = 100;
  sunLight.shadow.camera.top = 100;
  sunLight.shadow.camera.bottom = -100;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.bias = -0.001;
  sunLight.shadow.camera.near = 0.5;
  sunLight.shadow.camera.far = 500;
  scene.add(sunLight);

  const ambientLight = new THREE.AmbientLight(0x7d8a9e, 0.3);
  scene.add(ambientLight);

  const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x654321, 0.5);
  scene.add(hemisphereLight);

  const pointLight1 = new THREE.PointLight(0xff9500, 1, 30);
  pointLight1.position.set(10, 10, 10);
  pointLight1.castShadow = true;
  scene.add(pointLight1);

  const pointLight2 = new THREE.PointLight(0x0099ff, 1, 30);
  pointLight2.position.set(-10, 10, -10);
  pointLight2.castShadow = true;
  scene.add(pointLight2);

  // --- ENHANCED MATERIALS ---
  function createPBRMaterial(options) {
    const material = new THREE.MeshStandardMaterial({
      color: options.color || 0xffffff,
      roughness: options.roughness || 0.5,
      metalness: options.metalness || 0.0,
      map: options.map || null,
      normalMap: options.normalMap || null,
      roughnessMap: options.roughnessMap || null,
      metalnessMap: options.metalnessMap || null,
      aoMap: options.aoMap || null,
      envMapIntensity: options.envMapIntensity || 1.0
    });
    return material;
  }

  // --- MEDIKIT MODEL ---
  function createMedikitModel() {
    const model = new THREE.Group();
    
    // Main medikit box
    const boxGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.2);
    const boxMaterial = createPBRMaterial({ color: 0xffffff, roughness: 0.3 });
    const box = new THREE.Mesh(boxGeometry, boxMaterial);
    model.add(box);
    
    // Red cross on top
    const crossVerticalGeometry = new THREE.BoxGeometry(0.05, 0.2, 0.05);
    const crossMaterial = createPBRMaterial({ color: 0xff0000, roughness: 0.2, emissive: 0xff0000, emissiveIntensity: 0.3 });
    const crossVertical = new THREE.Mesh(crossVerticalGeometry, crossMaterial);
    crossVertical.position.y = 0.05;
    model.add(crossVertical);
    
    const crossHorizontalGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.05);
    const crossHorizontal = new THREE.Mesh(crossHorizontalGeometry, crossMaterial);
    crossHorizontal.position.y = 0.05;
    model.add(crossHorizontal);
    
    // Add glowing effect
    const glowLight = new THREE.PointLight(0x00ff00, 0.5, 5);
    model.add(glowLight);
    
    // Animation properties
    model.floatOffset = Math.random() * Math.PI * 2;
    model.rotationSpeed = 0.01 + Math.random() * 0.02;
    
    return model;
  }

  // --- RETRO-STYLE CHARACTER MODEL ---
  function createRetroStylePlayerModel() {
    const model = new THREE.Group();
    
    // Materials for different body parts
    const skinMaterial = createPBRMaterial({ color: 0xfdbcb4, roughness: 0.7 });
    const hairMaterial = createPBRMaterial({ color: 0x2c1810, roughness: 0.8 });
    
    // Plaid pattern material for coat
    const plaidTexture = new THREE.DataTexture(
      new Uint8Array([
        255, 0, 0, 255, 0, 255, 0, 255, 255, 0, 0, 255,
        0, 255, 0, 255, 255, 0, 0, 255, 0, 255, 0, 255,
        255, 0, 0, 255, 0, 255, 0, 255, 255, 0, 0, 255,
        0, 255, 0, 255, 255, 0, 0, 255, 0, 255, 0, 255
      ]), 4, 4, THREE.RGBAFormat
    );
    plaidTexture.magFilter = THREE.NearestFilter;
    plaidTexture.wrapS = THREE.RepeatWrapping;
    plaidTexture.wrapT = THREE.RepeatWrapping;
    plaidTexture.repeat.set(4, 4);
    
    const coatMaterial = createPBRMaterial({ 
      color: 0x8B0000, 
      roughness: 0.6,
      map: plaidTexture
    });
    
    const bowTieMaterial = createPBRMaterial({ color: 0xffffff, roughness: 0.5 });
    const glovesMaterial = createPBRMaterial({ color: 0xFFD700, roughness: 0.4 });
    const bagMaterial = createPBRMaterial({ color: 0x8B4513, roughness: 0.6 });
    const beltMaterial = createPBRMaterial({ color: 0x000000, roughness: 0.5 });
    
    // Head with more realistic shape
    const headGeometry = new THREE.SphereGeometry(0.45, 32, 32);
    const head = new THREE.Mesh(headGeometry, skinMaterial);
    head.position.y = 2.5;
    head.scale.set(1, 1.1, 0.9);
    model.add(head);
    
    // Hair
    const hairGeometry = new THREE.SphereGeometry(0.48, 16, 16);
    hairGeometry.scale(1, 0.6, 1.1);
    const hair = new THREE.Mesh(hairGeometry, hairMaterial);
    hair.position.y = 2.75;
    model.add(hair);
    
    // Neck
    const neckGeometry = new THREE.CylinderGeometry(0.2, 0.22, 0.3, 16);
    const neck = new THREE.Mesh(neckGeometry, skinMaterial);
    neck.position.y = 2.1;
    model.add(neck);
    
    // Torso with shirt
    const torsoGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.4);
    const torso = new THREE.Mesh(torsoGeometry, createPBRMaterial({ color: 0xffffff, roughness: 0.7 }));
    torso.position.y = 1.5;
    model.add(torso);
    
    // Plaid coat
    const coatGeometry = new THREE.BoxGeometry(0.9, 1.3, 0.45);
    const coat = new THREE.Mesh(coatGeometry, coatMaterial);
    coat.position.y = 1.5;
    model.add(coat);
    
    // White bow tie
    const bowTieGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.1);
    const bowTie = new THREE.Mesh(bowTieGeometry, bowTieMaterial);
    bowTie.position.set(0, 2.1, 0.25);
    model.add(bowTie);
    
    // Belt
    const beltGeometry = new THREE.BoxGeometry(0.85, 0.1, 0.5);
    const belt = new THREE.Mesh(beltGeometry, beltMaterial);
    belt.position.y = 1.2;
    model.add(belt);
    
    // Arms with realistic joints
    const shoulderGeometry = new THREE.SphereGeometry(0.15, 16, 16);
    const upperArmGeometry = new THREE.CylinderGeometry(0.12, 0.14, 0.7, 16);
    const elbowGeometry = new THREE.SphereGeometry(0.1, 16, 16);
    const lowerArmGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.6, 16);
    const handGeometry = new THREE.SphereGeometry(0.12, 16, 16);
    
    // Left arm
    const leftShoulder = new THREE.Mesh(shoulderGeometry, skinMaterial);
    leftShoulder.position.set(-0.45, 2.0, 0);
    model.add(leftShoulder);
    
    const leftUpperArm = new THREE.Mesh(upperArmGeometry, skinMaterial);
    leftUpperArm.position.set(-0.65, 1.7, 0);
    leftUpperArm.rotation.z = Math.PI / 2;
    model.add(leftUpperArm);
    
    const leftElbow = new THREE.Mesh(elbowGeometry, skinMaterial);
    leftElbow.position.set(-0.9, 1.3, 0);
    model.add(leftElbow);
    
    const leftLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
    leftLowerArm.position.set(-1.1, 1.0, 0);
    leftLowerArm.rotation.z = Math.PI / 2;
    model.add(leftLowerArm);
    
    const leftHand = new THREE.Mesh(handGeometry, glovesMaterial);
    leftHand.position.set(-1.3, 0.7, 0);
    model.add(leftHand);
    
    // Right arm
    const rightShoulder = new THREE.Mesh(shoulderGeometry, skinMaterial);
    rightShoulder.position.set(0.45, 2.0, 0);
    model.add(rightShoulder);
    
    const rightUpperArm = new THREE.Mesh(upperArmGeometry, skinMaterial);
    rightUpperArm.position.set(0.65, 1.7, 0);
    rightUpperArm.rotation.z = Math.PI / 2;
    model.add(rightUpperArm);
    
    const rightElbow = new THREE.Mesh(elbowGeometry, skinMaterial);
    rightElbow.position.set(0.9, 1.3, 0);
    model.add(rightElbow);
    
    const rightLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
    rightLowerArm.position.set(1.1, 1.0, 0);
    rightLowerArm.rotation.z = Math.PI / 2;
    model.add(rightLowerArm);
    
    const rightHand = new THREE.Mesh(handGeometry, glovesMaterial);
    rightHand.position.set(1.3, 0.7, 0);
    model.add(rightHand);
    
    // Legs with realistic joints
    const hipGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.4);
    const upperLegGeometry = new THREE.CylinderGeometry(0.15, 0.18, 0.8, 16);
    const kneeGeometry = new THREE.SphereGeometry(0.12, 16, 16);
    const lowerLegGeometry = new THREE.CylinderGeometry(0.12, 0.14, 0.7, 16);
    const footGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.6);
    
    // Hips
    const hips = new THREE.Mesh(hipGeometry, createPBRMaterial({ color: 0x333333, roughness: 0.7 }));
    hips.position.y = 0.9;
    model.add(hips);
    
    // Left leg
    const leftUpperLeg = new THREE.Mesh(upperLegGeometry, createPBRMaterial({ color: 0x333333, roughness: 0.7 }));
    leftUpperLeg.position.set(-0.2, 0.5, 0);
    model.add(leftUpperLeg);
    
    const leftKnee = new THREE.Mesh(kneeGeometry, skinMaterial);
    leftKnee.position.set(-0.2, 0.1, 0);
    model.add(leftKnee);
    
    const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, createPBRMaterial({ color: 0x333333, roughness: 0.7 }));
    leftLowerLeg.position.set(-0.2, -0.3, 0);
    model.add(leftLowerLeg);
    
    const leftFoot = new THREE.Mesh(footGeometry, createPBRMaterial({ color: 0x222222, roughness: 0.6 }));
    leftFoot.position.set(-0.2, -0.7, 0.1);
    model.add(leftFoot);
    
    // Right leg
    const rightUpperLeg = new THREE.Mesh(upperLegGeometry, createPBRMaterial({ color: 0x333333, roughness: 0.7 }));
    rightUpperLeg.position.set(0.2, 0.5, 0);
    model.add(rightUpperLeg);
    
    const rightKnee = new THREE.Mesh(kneeGeometry, skinMaterial);
    rightKnee.position.set(0.2, 0.1, 0);
    model.add(rightKnee);
    
    const rightLowerLeg = new THREE.Mesh(lowerLegGeometry, createPBRMaterial({ color: 0x333333, roughness: 0.7 }));
    rightLowerLeg.position.set(0.2, -0.3, 0);
    model.add(rightLowerLeg);
    
    const rightFoot = new THREE.Mesh(footGeometry, createPBRMaterial({ color: 0x222222, roughness: 0.6 }));
    rightFoot.position.set(0.2, -0.7, 0.1);
    model.add(rightFoot);
    
    // Brown suspenders bag
    const bagGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.2);
    const bag = new THREE.Mesh(bagGeometry, bagMaterial);
    bag.position.set(0.3, 1.3, 0.3);
    model.add(bag);
    
    // Suspenders
    const suspenderGeometry = new THREE.BoxGeometry(0.05, 0.8, 0.05);
    const leftSuspender = new THREE.Mesh(suspenderGeometry, bagMaterial);
    leftSuspender.position.set(-0.2, 1.6, 0.25);
    leftSuspender.rotation.z = 0.2;
    model.add(leftSuspender);
    
    const rightSuspender = new THREE.Mesh(suspenderGeometry, bagMaterial);
    rightSuspender.position.set(0.2, 1.6, 0.25);
    rightSuspender.rotation.z = -0.2;
    model.add(rightSuspender);
    
    // Store animation references
    model.leftUpperLeg = leftUpperLeg;
    model.leftLowerLeg = leftLowerLeg;
    model.rightUpperLeg = rightUpperLeg;
    model.rightLowerLeg = rightLowerLeg;
    model.leftUpperArm = leftUpperArm;
    model.leftLowerArm = leftLowerArm;
    model.rightUpperArm = rightUpperArm;
    model.rightLowerArm = rightLowerArm;
    model.leftHand = leftHand;
    model.rightHand = rightHand;
    model.torso = torso;
    
    model.traverse(child => { if (child instanceof THREE.Mesh) { child.castShadow = true; } });
    return model;
  }

  function createRealisticEnemyModel() {
    const model = new THREE.Group();
    
    // Enemy materials
    const skinMaterial = createPBRMaterial({ color: 0x8b6b47, roughness: 0.7 });
    const helmetMaterial = createPBRMaterial({ color: 0x006400, roughness: 0.3, metalness: 0.6 });
    const armorMaterial = createPBRMaterial({ color: 0x2d5016, roughness: 0.6 });
    const bootMaterial = createPBRMaterial({ color: 0x1a1a1a, roughness: 0.5 });
    
    // Head with realistic shape
    const headGeometry = new THREE.SphereGeometry(0.45, 32, 32);
    const head = new THREE.Mesh(headGeometry, skinMaterial);
    head.position.y = 2.5;
    head.scale.set(1, 1.1, 0.9);
    model.add(head);
    
    // Helmet
    const helmetGeometry = new THREE.SphereGeometry(0.5, 16, 16);
    const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
    helmet.position.y = 2.8;
    helmet.scale.set(1, 0.8, 1.2);
    model.add(helmet);
    
    // Helmet visor
    const visorGeometry = new THREE.BoxGeometry(0.4, 0.15, 0.1);
    const visor = new THREE.Mesh(visorGeometry, createPBRMaterial({ color: 0x000000, roughness: 0.2, metalness: 0.8 }));
    visor.position.set(0, 2.85, 0.25);
    model.add(visor);
    
    // Neck
    const neckGeometry = new THREE.CylinderGeometry(0.2, 0.22, 0.3, 16);
    const neck = new THREE.Mesh(neckGeometry, skinMaterial);
    neck.position.y = 2.1;
    model.add(neck);
    
    // Body armor
    const bodyGeometry = new THREE.BoxGeometry(0.9, 1.3, 0.4);
    const body = new THREE.Mesh(bodyGeometry, armorMaterial);
    body.position.y = 1.5;
    model.add(body);
    
    // Shoulder armor
    const leftShoulderArmor = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.5), armorMaterial);
    leftShoulderArmor.position.set(-0.6, 2.0, 0);
    model.add(leftShoulderArmor);
    
    const rightShoulderArmor = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.5), armorMaterial);
    rightShoulderArmor.position.set(0.6, 2.0, 0);
    model.add(rightShoulderArmor);
    
    // Arms with armor
    const upperArmGeometry = new THREE.CylinderGeometry(0.13, 0.15, 0.7, 16);
    const lowerArmGeometry = new THREE.CylinderGeometry(0.11, 0.13, 0.6, 16);
    const handGeometry = new THREE.SphereGeometry(0.12, 16, 16);
    
    // Left arm
    const leftUpperArm = new THREE.Mesh(upperArmGeometry, armorMaterial);
    leftUpperArm.position.set(-0.65, 1.7, 0);
    leftUpperArm.rotation.z = Math.PI / 2;
    model.add(leftUpperArm);
    
    const leftLowerArm = new THREE.Mesh(lowerArmGeometry, armorMaterial);
    leftLowerArm.position.set(-0.95, 1.3, 0);
    leftLowerArm.rotation.z = Math.PI / 2;
    model.add(leftLowerArm);
    
    const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
    leftHand.position.set(-1.2, 1.0, 0);
    model.add(leftHand);
    
    // Right arm
    const rightUpperArm = new THREE.Mesh(upperArmGeometry, armorMaterial);
    rightUpperArm.position.set(0.65, 1.7, 0);
    rightUpperArm.rotation.z = Math.PI / 2;
    model.add(rightUpperArm);
    
    const rightLowerArm = new THREE.Mesh(lowerArmGeometry, armorMaterial);
    rightLowerArm.position.set(0.95, 1.3, 0);
    rightLowerArm.rotation.z = Math.PI / 2;
    model.add(rightLowerArm);
    
    const rightHand = new THREE.Mesh(handGeometry, skinMaterial);
    rightHand.position.set(1.2, 1.0, 0);
    model.add(rightHand);
    
    // Legs with armor
    const upperLegGeometry = new THREE.CylinderGeometry(0.16, 0.18, 0.8, 16);
    const lowerLegGeometry = new THREE.CylinderGeometry(0.13, 0.15, 0.7, 16);
    const footGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.6);
    
    // Left leg
    const leftUpperLeg = new THREE.Mesh(upperLegGeometry, armorMaterial);
    leftUpperLeg.position.set(-0.25, 0.5, 0);
    model.add(leftUpperLeg);
    
    const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, armorMaterial);
    leftLowerLeg.position.set(-0.25, -0.3, 0);
    model.add(leftLowerLeg);
    
    const leftFoot = new THREE.Mesh(footGeometry, bootMaterial);
    leftFoot.position.set(-0.25, -0.7, 0.1);
    model.add(leftFoot);
    
    // Right leg
    const rightUpperLeg = new THREE.Mesh(upperLegGeometry, armorMaterial);
    rightUpperLeg.position.set(0.25, 0.5, 0);
    model.add(rightUpperLeg);
    
    const rightLowerLeg = new THREE.Mesh(lowerLegGeometry, armorMaterial);
    rightLowerLeg.position.set(0.25, -0.3, 0);
    model.add(rightLowerLeg);
    
    const rightFoot = new THREE.Mesh(footGeometry, bootMaterial);
    rightFoot.position.set(0.25, -0.7, 0.1);
    model.add(rightFoot);
    
    // Rocket launcher
    const launcherGeometry = new THREE.BoxGeometry(0.4, 0.3, 1.5);
    const launcher = new THREE.Mesh(launcherGeometry, createPBRMaterial({ color: 0x222222, roughness: 0.2, metalness: 0.8 }));
    launcher.position.set(1.0, 1.3, 0.2);
    launcher.rotation.z = Math.PI / 2;
    launcher.rotation.x = 0.2;
    rightLowerArm.add(launcher);
    
    // Store animation references
    model.leftUpperLeg = leftUpperLeg;
    model.leftLowerLeg = leftLowerLeg;
    model.rightUpperLeg = rightUpperArm;
    model.rightLowerLeg = rightLowerArm;
    model.leftUpperArm = leftUpperArm;
    model.leftLowerArm = leftLowerArm;
    model.rightUpperArm = rightUpperArm;
    model.rightLowerArm = rightLowerArm;
    model.rightHand = rightHand;
    model.torso = body;
    
    model.health = 100;
    model.maxHealth = 100;
    model.speed = 0.08;
    model.fireRate = 1500;
    model.lastShotTime = 0;
    model.shootingRange = 35;
    model.state = 'patrol';
    model.targetPosition = null;
    model.lastStateChange = 0;
    model.coverPosition = null;
    model.animationTime = 0;
    model.prevX = 0;
    model.prevZ = 0;
    model.walkCycle = 0;
    model.isBoss = false;
    model.isMinion = false;
    
    model.traverse(child => { if (child instanceof THREE.Mesh) { child.castShadow = true; } });
    return model;
  }

  // --- DEMON KING BOSS MODEL ---
  function createDemonKingModel() {
    const model = new THREE.Group();
    
    // Demon King materials - dark red and black with glowing effects
    const skinMaterial = createPBRMaterial({ color: 0x4a0000, roughness: 0.7 });
    const armorMaterial = createPBRMaterial({ color: 0x1a0000, roughness: 0.4, metalness: 0.6 });
    const crownMaterial = createPBRMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.9 });
    const capeMaterial = createPBRMaterial({ color: 0x8b0000, roughness: 0.8 });
    const eyeMaterial = createPBRMaterial({ color: 0xff0000, roughness: 0.2, emissive: 0xff0000, emissiveIntensity: 0.8 });
    const hornMaterial = createPBRMaterial({ color: 0x222222, roughness: 0.3, metalness: 0.7 });
    
    // Scale factor for demon king (2x bigger than normal enemy)
    const scale = 2.0;
    
    // Head with demonic features
    const headGeometry = new THREE.BoxGeometry(0.8 * scale, 0.9 * scale, 0.7 * scale);
    const head = new THREE.Mesh(headGeometry, skinMaterial);
    head.position.y = 2.8 * scale;
    model.add(head);
    
    // Glowing demonic eyes
    const leftEyeGeometry = new THREE.SphereGeometry(0.12 * scale, 8, 8);
    const leftEye = new THREE.Mesh(leftEyeGeometry, eyeMaterial);
    leftEye.position.set(-0.2 * scale, 2.9 * scale, 0.35 * scale);
    model.add(leftEye);
    
    const rightEyeGeometry = new THREE.SphereGeometry(0.12 * scale, 8, 8);
    const rightEye = new THREE.Mesh(rightEyeGeometry, eyeMaterial);
    rightEye.position.set(0.2 * scale, 2.9 * scale, 0.35 * scale);
    model.add(rightEye);
    
    // Demon horns
    for (let i = 0; i < 2; i++) {
      const hornGeometry = new THREE.ConeGeometry(0.08 * scale, 0.8 * scale, 6);
      const horn = new THREE.Mesh(hornGeometry, hornMaterial);
      horn.position.set((i === 0 ? -0.3 : 0.3) * scale, 3.4 * scale, 0);
      horn.rotation.z = (i === 0 ? 0.2 : -0.2);
      model.add(horn);
    }
    
    // Crown
    const crownGeometry = new THREE.CylinderGeometry(0.6 * scale, 0.7 * scale, 0.2 * scale, 8);
    const crown = new THREE.Mesh(crownGeometry, crownMaterial);
    crown.position.y = 3.6 * scale;
    model.add(crown);
    
    // Crown spikes
    for (let i = 0; i < 8; i++) {
      const spikeGeometry = new THREE.ConeGeometry(0.05 * scale, 0.3 * scale, 4);
      const spike = new THREE.Mesh(spikeGeometry, crownMaterial);
      const angle = (i / 8) * Math.PI * 2;
      spike.position.set(
        Math.cos(angle) * 0.6 * scale,
        3.8 * scale,
        Math.sin(angle) * 0.6 * scale
      );
      model.add(spike);
    }
    
    // Neck
    const neckGeometry = new THREE.CylinderGeometry(0.3 * scale, 0.35 * scale, 0.4 * scale, 16);
    const neck = new THREE.Mesh(neckGeometry, skinMaterial);
    neck.position.y = 2.2 * scale;
    model.add(neck);
    
    // Muscular torso
    const torsoGeometry = new THREE.BoxGeometry(1.2 * scale, 1.8 * scale, 0.6 * scale);
    const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
    torso.position.y = 1.5 * scale;
    model.add(torso);
    
    // Cape
    const capeGeometry = new THREE.PlaneGeometry(2.0 * scale, 2.5 * scale);
    const cape = new THREE.Mesh(capeGeometry, capeMaterial);
    cape.position.set(0, 1.5 * scale, -0.4 * scale);
    cape.rotation.x = Math.PI / 8;
    model.add(cape);
    
    // Shoulder armor with spikes
    const leftShoulderArmor = new THREE.Mesh(new THREE.BoxGeometry(0.5 * scale, 0.3 * scale, 0.6 * scale), armorMaterial);
    leftShoulderArmor.position.set(-0.8 * scale, 2.4 * scale, 0);
    model.add(leftShoulderArmor);
    
    const rightShoulderArmor = new THREE.Mesh(new THREE.BoxGeometry(0.5 * scale, 0.3 * scale, 0.6 * scale), armorMaterial);
    rightShoulderArmor.position.set(0.8 * scale, 2.4 * scale, 0);
    model.add(rightShoulderArmor);
    
    // Shoulder spikes
    const leftShoulderSpike = new THREE.Mesh(new THREE.ConeGeometry(0.1 * scale, 0.4 * scale, 4), hornMaterial);
    leftShoulderSpike.position.set(-0.8 * scale, 2.6 * scale, 0);
    model.add(leftShoulderSpike);
    
    const rightShoulderSpike = new THREE.Mesh(new THREE.ConeGeometry(0.1 * scale, 0.4 * scale, 4), hornMaterial);
    rightShoulderSpike.position.set(0.8 * scale, 2.6 * scale, 0);
    model.add(rightShoulderSpike);
    
    // Muscular arms
    const upperArmGeometry = new THREE.CylinderGeometry(0.2 * scale, 0.22 * scale, 0.9 * scale, 16);
    const lowerArmGeometry = new THREE.CylinderGeometry(0.18 * scale, 0.2 * scale, 0.8 * scale, 16);
    const handGeometry = new THREE.BoxGeometry(0.3 * scale, 0.2 * scale, 0.5 * scale);
    
    // Left arm
    const leftUpperArm = new THREE.Mesh(upperArmGeometry, skinMaterial);
    leftUpperArm.position.set(-0.9 * scale, 1.8 * scale, 0);
    leftUpperArm.rotation.z = Math.PI / 2;
    model.add(leftUpperArm);
    
    const leftLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
    leftLowerArm.position.set(-1.3 * scale, 1.3 * scale, 0);
    leftLowerArm.rotation.z = Math.PI / 2;
    model.add(leftLowerArm);
    
    const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
    leftHand.position.set(-1.6 * scale, 0.9 * scale, 0);
    model.add(leftHand);
    
    // Right arm with weapon
    const rightUpperArm = new THREE.Mesh(upperArmGeometry, skinMaterial);
    rightUpperArm.position.set(0.9 * scale, 1.8 * scale, 0);
    rightUpperArm.rotation.z = Math.PI / 2;
    model.add(rightUpperArm);
    
    const rightLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
    rightLowerArm.position.set(1.3 * scale, 1.3 * scale, 0);
    rightLowerArm.rotation.z = Math.PI / 2;
    model.add(rightLowerArm);
    
    const rightHand = new THREE.Mesh(handGeometry, skinMaterial);
    rightHand.position.set(1.6 * scale, 0.9 * scale, 0);
    model.add(rightHand);
    
    // Demon sword
    const swordGeometry = new THREE.BoxGeometry(0.15 * scale, 0.3 * scale, 2.5 * scale);
    const sword = new THREE.Mesh(swordGeometry, createPBRMaterial({ color: 0x444444, roughness: 0.2, metalness: 0.9 }));
    sword.position.set(1.6 * scale, 1.3 * scale, 0.5 * scale);
    sword.rotation.x = Math.PI / 2;
    sword.rotation.z = Math.PI / 4;
    rightHand.add(sword);
    
    // Sword glow effect
    const swordGlow = new THREE.PointLight(0xff0000, 0.8, 15);
    sword.add(swordGlow);
    
    // Muscular legs
    const upperLegGeometry = new THREE.CylinderGeometry(0.25 * scale, 0.28 * scale, 1.0 * scale, 16);
    const lowerLegGeometry = new THREE.CylinderGeometry(0.2 * scale, 0.22 * scale, 0.9 * scale, 16);
    const footGeometry = new THREE.BoxGeometry(0.4 * scale, 0.2 * scale, 0.8 * scale);
    
    // Left leg
    const leftUpperLeg = new THREE.Mesh(upperLegGeometry, armorMaterial);
    leftUpperLeg.position.set(-0.4 * scale, 0.6 * scale, 0);
    model.add(leftUpperLeg);
    
    const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, armorMaterial);
    leftLowerLeg.position.set(-0.4 * scale, -0.3 * scale, 0);
    model.add(leftLowerLeg);
    
    const leftFoot = new THREE.Mesh(footGeometry, createPBRMaterial({ color: 0x222222, roughness: 0.6 }));
    leftFoot.position.set(-0.4 * scale, -0.8 * scale, 0.2 * scale);
    model.add(leftFoot);
    
    // Right leg
    const rightUpperLeg = new THREE.Mesh(upperLegGeometry, armorMaterial);
    rightUpperLeg.position.set(0.4 * scale, 0.6 * scale, 0);
    model.add(rightUpperLeg);
    
    const rightLowerLeg = new THREE.Mesh(lowerLegGeometry, armorMaterial);
    rightLowerLeg.position.set(0.4 * scale, -0.3 * scale, 0);
    model.add(rightLowerLeg);
    
    const rightFoot = new THREE.Mesh(footGeometry, createPBRMaterial({ color: 0x222222, roughness: 0.6 }));
    rightFoot.position.set(0.4 * scale, -0.8 * scale, 0.2 * scale);
    model.add(rightFoot);
    
    // Store animation references
    model.leftUpperLeg = leftUpperLeg;
    model.leftLowerLeg = leftLowerLeg;
    model.rightUpperLeg = rightUpperArm;
    model.rightLowerLeg = rightLowerArm;
    model.leftUpperArm = leftUpperArm;
    model.leftLowerArm = leftLowerArm;
    model.rightUpperArm = rightUpperArm;
    model.rightLowerArm = rightLowerArm;
    model.rightHand = rightHand;
    model.torso = torso;
    
    // Demon King properties
    model.health = 1000;
    model.maxHealth = 1000;
    model.speed = 0.05;
    model.fireRate = 600;
    model.lastShotTime = 0;
    model.shootingRange = 60;
    model.state = 'patrol';
    model.targetPosition = null;
    model.lastStateChange = 0;
    model.coverPosition = null;
    model.animationTime = 0;
    model.prevX = 0;
    model.prevZ = 0;
    model.walkCycle = 0;
    model.isBoss = true;
    model.isDemonKing = true;
    model.specialAttackCooldown = 0;
    model.minionSpawnCooldown = 0;
    
    model.traverse(child => { if (child instanceof THREE.Mesh) { child.castShadow = true; } });
    return model;
  }

  // --- DEMON MINION MODEL ---
  function createDemonMinionModel() {
    const model = new THREE.Group();
    
    // Minion materials - goblin-like appearance
    const skinMaterial = createPBRMaterial({ color: 0x2d1810, roughness: 0.8 });
    const armorMaterial = createPBRMaterial({ color: 0x1a0a00, roughness: 0.7 });
    const eyeMaterial = createPBRMaterial({ color: 0xff0000, roughness: 0.2, emissive: 0xff0000, emissiveIntensity: 0.6 });
    
    // Scale factor for minions (0.7x normal size)
    const scale = 0.7;
    
    // Head with goblin features
    const headGeometry = new THREE.BoxGeometry(0.5 * scale, 0.6 * scale, 0.4 * scale);
    const head = new THREE.Mesh(headGeometry, skinMaterial);
    head.position.y = 1.8 * scale;
    head.scale.set(1, 1.2, 0.9);
    model.add(head);
    
    // Pointed ears
    const leftEarGeometry = new THREE.ConeGeometry(0.1 * scale, 0.3 * scale, 4);
    const leftEar = new THREE.Mesh(leftEarGeometry, skinMaterial);
    leftEar.position.set(-0.25 * scale, 2.0 * scale, 0);
    leftEar.rotation.z = -0.5;
    model.add(leftEar);
    
    const rightEarGeometry = new THREE.ConeGeometry(0.1 * scale, 0.3 * scale, 4);
    const rightEar = new THREE.Mesh(rightEarGeometry, skinMaterial);
    rightEar.position.set(0.25 * scale, 2.0 * scale, 0);
    rightEar.rotation.z = 0.5;
    model.add(rightEar);
    
    // Glowing red eyes
    const leftEyeGeometry = new THREE.SphereGeometry(0.08 * scale, 6, 6);
    const leftEye = new THREE.Mesh(leftEyeGeometry, eyeMaterial);
    leftEye.position.set(-0.15 * scale, 1.9 * scale, 0.2 * scale);
    model.add(leftEye);
    
    const rightEyeGeometry = new THREE.SphereGeometry(0.08 * scale, 6, 6);
    const rightEye = new THREE.Mesh(rightEyeGeometry, eyeMaterial);
    rightEye.position.set(0.15 * scale, 1.9 * scale, 0.2 * scale);
    model.add(rightEye);
    
    // Small horns
    for (let i = 0; i < 2; i++) {
      const hornGeometry = new THREE.ConeGeometry(0.04 * scale, 0.2 * scale, 4);
      const horn = new THREE.Mesh(hornGeometry, createPBRMaterial({ color: 0x222222, roughness: 0.5 }));
      horn.position.set((i === 0 ? -0.2 : 0.2) * scale, 2.2 * scale, 0);
      horn.rotation.z = (i === 0 ? 0.3 : -0.3);
      model.add(horn);
    }
    
    // Neck
    const neckGeometry = new THREE.CylinderGeometry(0.15 * scale, 0.18 * scale, 0.3 * scale, 12);
    const neck = new THREE.Mesh(neckGeometry, skinMaterial);
    neck.position.y = 1.5 * scale;
    model.add(neck);
    
    // Small body
    const bodyGeometry = new THREE.BoxGeometry(0.7 * scale, 0.9 * scale, 0.4 * scale);
    const body = new THREE.Mesh(bodyGeometry, armorMaterial);
    body.position.y = 0.9 * scale;
    model.add(body);
    
    // Arms with claws
    const upperArmGeometry = new THREE.CylinderGeometry(0.1 * scale, 0.12 * scale, 0.6 * scale, 12);
    const lowerArmGeometry = new THREE.CylinderGeometry(0.08 * scale, 0.1 * scale, 0.5 * scale, 12);
    const handGeometry = new THREE.BoxGeometry(0.15 * scale, 0.1 * scale, 0.3 * scale);
    
    // Left arm
    const leftUpperArm = new THREE.Mesh(upperArmGeometry, skinMaterial);
    leftUpperArm.position.set(-0.45 * scale, 1.1 * scale, 0);
    leftUpperArm.rotation.z = Math.PI / 2;
    model.add(leftUpperArm);
    
    const leftLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
    leftLowerArm.position.set(-0.7 * scale, 0.8 * scale, 0);
    leftLowerArm.rotation.z = Math.PI / 2;
    model.add(leftLowerArm);
    
    const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
    leftHand.position.set(-0.85 * scale, 0.6 * scale, 0);
    model.add(leftHand);
    
    // Left claws
    for (let i = 0; i < 3; i++) {
      const clawGeometry = new THREE.ConeGeometry(0.02 * scale, 0.15 * scale, 4);
      const claw = new THREE.Mesh(clawGeometry, createPBRMaterial({ color: 0x111111, roughness: 0.3 }));
      claw.position.set(-0.85 * scale, 0.6 * scale, 0.1 + i * 0.05);
      claw.rotation.x = Math.PI / 2;
      leftHand.add(claw);
    }
    
    // Right arm
    const rightUpperArm = new THREE.Mesh(upperArmGeometry, skinMaterial);
    rightUpperArm.position.set(0.45 * scale, 1.1 * scale, 0);
    rightUpperArm.rotation.z = Math.PI / 2;
    model.add(rightUpperArm);
    
    const rightLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
    rightLowerArm.position.set(0.7 * scale, 0.8 * scale, 0);
    rightLowerArm.rotation.z = Math.PI / 2;
    model.add(rightLowerArm);
    
    const rightHand = new THREE.Mesh(handGeometry, skinMaterial);
    rightHand.position.set(0.85 * scale, 0.6 * scale, 0);
    model.add(rightHand);
    
    // Right claws
    for (let i = 0; i < 3; i++) {
      const clawGeometry = new THREE.ConeGeometry(0.02 * scale, 0.15 * scale, 4);
      const claw = new THREE.Mesh(clawGeometry, createPBRMaterial({ color: 0x111111, roughness: 0.3 }));
      claw.position.set(0.85 * scale, 0.6 * scale, 0.1 + i * 0.05);
      claw.rotation.x = Math.PI / 2;
      rightHand.add(claw);
    }
    
    // Small legs
    const upperLegGeometry = new THREE.CylinderGeometry(0.12 * scale, 0.14 * scale, 0.6 * scale, 12);
    const lowerLegGeometry = new THREE.CylinderGeometry(0.1 * scale, 0.12 * scale, 0.5 * scale, 12);
    const footGeometry = new THREE.BoxGeometry(0.2 * scale, 0.1 * scale, 0.4 * scale);
    
    // Left leg
    const leftUpperLeg = new THREE.Mesh(upperLegGeometry, armorMaterial);
    leftUpperLeg.position.set(-0.2 * scale, 0.3 * scale, 0);
    model.add(leftUpperLeg);
    
    const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, armorMaterial);
    leftLowerLeg.position.set(-0.2 * scale, -0.2 * scale, 0);
    model.add(leftLowerLeg);
    
    const leftFoot = new THREE.Mesh(footGeometry, createPBRMaterial({ color: 0x111111, roughness: 0.7 }));
    leftFoot.position.set(-0.2 * scale, -0.5 * scale, 0.1 * scale);
    model.add(leftFoot);
    
    // Right leg
    const rightUpperLeg = new THREE.Mesh(upperLegGeometry, armorMaterial);
    rightUpperLeg.position.set(0.2 * scale, 0.3 * scale, 0);
    model.add(rightUpperLeg);
    
    const rightLowerLeg = new THREE.Mesh(lowerLegGeometry, armorMaterial);
    rightLowerLeg.position.set(0.2 * scale, -0.2 * scale, 0);
    model.add(rightLowerLeg);
    
    const rightFoot = new THREE.Mesh(footGeometry, createPBRMaterial({ color: 0x111111, roughness: 0.7 }));
    rightFoot.position.set(0.2 * scale, -0.5 * scale, 0.1 * scale);
    model.add(rightFoot);
    
    // Store animation references
    model.leftUpperLeg = leftUpperLeg;
    model.leftLowerLeg = leftLowerLeg;
    model.rightUpperLeg = rightUpperLeg;
    model.rightLowerLeg = rightLowerLeg;
    model.leftUpperArm = leftUpperArm;
    model.leftLowerArm = leftLowerArm;
    model.rightUpperArm = rightUpperArm;
    model.rightLowerArm = rightLowerArm;
    model.rightHand = rightHand;
    model.torso = body;
    
    // Minion properties
    model.health = 50;
    model.maxHealth = 50;
    model.speed = 0.12; // Faster than regular enemies
    model.fireRate = 2000;
    model.lastShotTime = 0;
    model.shootingRange = 25;
    model.state = 'patrol';
    model.targetPosition = null;
    model.lastStateChange = 0;
    model.coverPosition = null;
    model.animationTime = 0;
    model.prevX = 0;
    model.prevZ = 0;
    model.walkCycle = 0;
    model.isBoss = false;
    model.isMinion = true;
    
    model.traverse(child => { if (child instanceof THREE.Mesh) { child.castShadow = true; } });
    return model;
  }

  // --- VILLAGE ENVIRONMENT ---
  function createSky() {
    const skyGeometry = new THREE.SphereGeometry(800, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({
      color: 0x87ceeb,
      side: THREE.BackSide,
      fog: false
    });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    const cloudGeometry = new THREE.PlaneGeometry(100, 100);
    const cloudMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.7,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < 20; i++) {
      const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
      cloud.position.set(
        (Math.random() - 0.5) * 400,
        50 + Math.random() * 50,
        (Math.random() - 0.5) * 400
      );
      cloud.rotation.x = Math.PI / 2;
      cloud.scale.set(
        0.5 + Math.random() * 1.5,
        0.5 + Math.random() * 1.5,
        1
      );
      scene.add(cloud);
    }
  }

  function createVillageHouse(x, z, houseType = 'normal') {
    const house = new THREE.Group();
    
    // Different house types for variety
    let width, depth, height, wallColor, roofColor;
    
    switch(houseType) {
      case 'small':
        width = 6 + Math.random() * 2;
        depth = 6 + Math.random() * 2;
        height = 4 + Math.random() * 2;
        wallColor = 0xD2691E;
        roofColor = 0x8B4513;
        break;
      case 'large':
        width = 10 + Math.random() * 3;
        depth = 10 + Math.random() * 3;
        height = 8 + Math.random() * 3;
        wallColor = 0xCD853F;
        roofColor = 0xA0522D;
        break;
      default:
        width = 8 + Math.random() * 2;
        depth = 8 + Math.random() * 2;
        height = 6 + Math.random() * 2;
        wallColor = 0xDEB887;
        roofColor = 0x8B4513;
    }
    
    // Foundation
    const foundationMaterial = createPBRMaterial({ color: 0x8B7355, roughness: 0.9 });
    const foundation = new THREE.Mesh(
      new THREE.BoxGeometry(width, 0.5, depth),
      foundationMaterial
    );
    foundation.position.y = 0.25;
    foundation.receiveShadow = true;
    house.add(foundation);
    
    // Walls
    const wallMaterial = createPBRMaterial({ color: wallColor, roughness: 0.8 });
    const wallThickness = 0.3;
    
    // Front wall
    const frontWall = new THREE.Mesh(
      new THREE.BoxGeometry(width, height, wallThickness),
      wallMaterial
    );
    frontWall.position.set(0, height / 2 + 0.5, -depth / 2);
    frontWall.castShadow = true;
    house.add(frontWall);
    
    // Back wall
    const backWall = new THREE.Mesh(
      new THREE.BoxGeometry(width, height, wallThickness),
      wallMaterial
    );
    backWall.position.set(0, height / 2 + 0.5, depth / 2);
    backWall.castShadow = true;
    house.add(backWall);
    
    // Left wall
    const leftWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, height, depth),
      wallMaterial
    );
    leftWall.position.set(-width / 2, height / 2 + 0.5, 0);
    leftWall.castShadow = true;
    house.add(leftWall);
    
    // Right wall
    const rightWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, height, depth),
      wallMaterial
    );
    rightWall.position.set(width / 2, height / 2 + 0.5, 0);
    rightWall.castShadow = true;
    house.add(rightWall);
    
    // Roof
    const roofMaterial = createPBRMaterial({ color: roofColor, roughness: 0.7 });
    const roofGeometry = new THREE.ConeGeometry(width * 0.7, height * 0.4, 8);
    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
    roof.position.y = height + 0.5;
    roof.rotation.x = Math.PI;
    roof.castShadow = true;
    house.add(roof);
    
    // Door
    const doorMaterial = createPBRMaterial({ color: 0x654321, roughness: 0.8 });
    const door = new THREE.Mesh(
      new THREE.BoxGeometry(1.2, 2.0, 0.2),
      doorMaterial
    );
    door.position.set(0, 1.5, -depth / 2);
    house.add(door);
    
    // Windows
    const windowMaterial = createPBRMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.6 });
    
    // Front windows
    const leftWindow = new THREE.Mesh(
      new THREE.BoxGeometry(1.0, 1.0, 0.1),
      windowMaterial
    );
    leftWindow.position.set(-width / 3, height / 2 + 0.5, -depth / 2);
    house.add(leftWindow);
    
    const rightWindow = new THREE.Mesh(
      new THREE.BoxGeometry(1.0, 1.0, 0.1),
      windowMaterial
    );
    rightWindow.position.set(width / 3, height / 2 + 0.5, -depth / 2);
    house.add(rightWindow);
    
    // Chimney (for some houses)
    if (Math.random() > 0.5) {
      const chimneyMaterial = createPBRMaterial({ color: 0x8B4513, roughness: 0.8 });
      const chimney = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 2, 0.6),
        chimneyMaterial
      );
      chimney.position.set((Math.random() - 0.5) * width * 0.6, height + 1, (Math.random() - 0.5) * depth * 0.6);
      chimney.castShadow = true;
      house.add(chimney);
    }
    
    house.position.set(x, 0, z);
    return house;
  }

  function createVillage() {
    createSky();
    
    // Ground
    const groundMaterial = createPBRMaterial({ color: 0x7CFC00, roughness: 0.8 });
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(500, 500),
      groundMaterial
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Add terrain variations
    for (let i = 0; i < 50; i++) {
      const terrain = new THREE.Mesh(
        new THREE.CircleGeometry(2 + Math.random() * 3, 8),
        createPBRMaterial({ color: Math.random() > 0.5 ? 0x90EE90 : 0x7CFC00, roughness: 0.9 })
      );
      terrain.position.set(
        (Math.random() - 0.5) * 200,
        0.01,
        (Math.random() - 0.5) * 200
      );
      terrain.rotation.x = -Math.PI / 2;
      scene.add(terrain);
    }
    
    // Create village layout with roads
    const villageCenter = { x: 0, z: 0 };
    const housePositions = [];
    
    // Main street houses
    for (let i = -5; i <= 5; i++) {
      if (i !== 0) {
        housePositions.push({ x: i * 15, z: 0, type: 'normal' });
        housePositions.push({ x: i * 15, z: 15, type: 'normal' });
        housePositions.push({ x: i * 15, z: -15, type: 'normal' });
      }
    }
    
    // Side streets
    for (let i = -4; i <= 4; i++) {
      if (i !== 0) {
        housePositions.push({ x: 0, z: i * 12, type: i % 2 === 0 ? 'normal' : 'small' });
        housePositions.push({ x: 20, z: i * 12, type: i % 2 === 0 ? 'normal' : 'small' });
        housePositions.push({ x: -20, z: i * 12, type: i % 2 === 0 ? 'normal' : 'small' });
      }
    }
    
    // Create a grid of houses around the center
    for (let x = -3; x <= 3; x++) {
      for (let z = -3; z <= 3; z++) {
        if (x !== 0 || z !== 0) {
          const distance = Math.sqrt(x * x + z * z);
          let houseType = 'normal';
          if (distance > 2.5) houseType = 'small';
          if (distance < 1.5 && Math.random() > 0.7) houseType = 'large';
          
          housePositions.push({
            x: x * 25 + (Math.random() - 0.5) * 8,
            z: z * 25 + (Math.random() - 0.5) * 8,
            type: houseType
          });
        }
      }
    }
    
    // Outer village houses
    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
      const distance = 80 + Math.random() * 40;
      housePositions.push({
        x: Math.cos(angle) * distance,
        z: Math.sin(angle) * distance,
        type: 'small'
      });
    }
    
    // Create all houses and add collision boxes
    housePositions.forEach(pos => {
      const house = createVillageHouse(pos.x, pos.z, pos.type);
      scene.add(house);
      
      // Add collision box for this house
      const houseWidth = pos.type === 'small' ? 7 : (pos.type === 'large' ? 12 : 9);
      const houseDepth = pos.type === 'small' ? 7 : (pos.type === 'large' ? 12 : 9);
      addCollisionBox(
        pos.x - houseWidth / 2,
        pos.x + houseWidth / 2,
        pos.z - houseDepth / 2,
        pos.z + houseDepth / 2
      );
    });
    
    // Add trees and vegetation
    for (let i = 0; i < 40; i++) {
      const treeType = Math.random() > 0.5 ? 'pine' : 'palm';
      const tree = createTree(
        (Math.random() - 0.5) * 200,
        (Math.random() - 0.5) * 200,
        treeType,
        0.6 + Math.random() * 0.8
      );
      scene.add(tree);
    }
    
    // Add rocks and decorative elements
    for (let i = 0; i < 30; i++) {
      const rock = new THREE.Mesh(
        new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.4),
        createPBRMaterial({ color: 0x808080, roughness: 0.9 })
      );
      rock.position.set(
        (Math.random() - 0.5) * 200,
        0.3,
        (Math.random() - 0.5) * 200
      );
      rock.castShadow = true;
      scene.add(rock);
    }
    
    // Add village well in center
    const wellGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 16);
    const wellMaterial = createPBRMaterial({ color: 0x8B4513, roughness: 0.8 });
    const well = new THREE.Mesh(wellGeometry, wellMaterial);
    well.position.set(0, 0.15, 0);
    scene.add(well);
  }

  function createTree(x, z, type = 'pine', scale = 1) {
    const tree = new THREE.Group();
    
    if (type === 'pine') {
      // Pine tree
      const trunkGeometry = new THREE.CylinderGeometry(0.3 * scale, 0.4 * scale, 4 * scale, 8);
      const trunkMaterial = createPBRMaterial({ color: 0x8B4513, roughness: 0.8 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 2 * scale;
      trunk.castShadow = true;
      tree.add(trunk);
      
      const leafMaterial = createPBRMaterial({ color: 0x228B22, roughness: 0.7 });
      
      for (let i = 0; i < 4; i++) {
        const layerGeometry = new THREE.ConeGeometry(
          (1.5 - i * 0.3) * scale,
          2 * scale,
          8
        );
        const layer = new THREE.Mesh(layerGeometry, leafMaterial);
        layer.position.y = (3 + i * 1.5) * scale;
        layer.castShadow = true;
        tree.add(layer);
      }
    } else {
      // Palm tree
      const trunkGeometry = new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 5 * scale, 8);
      const trunkMaterial = createPBRMaterial({ color: 0x8B4513, roughness: 0.8 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 2.5 * scale;
      trunk.castShadow = true;
      tree.add(trunk);
      
      const leafMaterial = createPBRMaterial({ color: 0x2E7D32, roughness: 0.7 });
      
      for (let i = 0; i < 8; i++) {
        const leafGeometry = new THREE.ConeGeometry(0.8 * scale, 3 * scale, 8);
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        leaf.position.y = (4 + Math.random() * 0.5) * scale;
        leaf.rotation.x = Math.random() * 0.5;
        leaf.rotation.z = (Math.random() - 0.5) * 0.5;
        leaf.rotation.y = (i * Math.PI / 4);
        leaf.castShadow = true;
        tree.add(leaf);
      }
    }
    
    tree.position.set(x, 0, z);
    return tree;
  }

  // --- COLLISION SYSTEM ---
  const collisionBoxes = [];
  function addCollisionBox(minX, maxX, minZ, maxZ) {
    collisionBoxes.push({ minX, maxX, minZ, maxZ });
  }

  function checkCollision(x, z, radius = 0.5) {
    for (const box of collisionBoxes) {
      if (x + radius > box.minX && x - radius < box.maxX &&
          z + radius > box.minZ && z - radius < box.maxZ) {
        return true;
      }
    }
    return false;
  }

  // --- ENEMY AI WITH REALISTIC MOVEMENT ---
  function updateEnemyAI(enemy, currentTime) {
    const playerDistance = camera.position.distanceTo(enemy.position);
    enemy.walkCycle += 0.15;
    
    // Realistic walking animation
    const walkSpeed = enemy.state === 'patrol' ? 0.3 : 0.6;
    if (Math.abs(enemy.position.x - enemy.prevX) > 0.01 || Math.abs(enemy.position.z - enemy.prevZ) > 0.01) {
      // Leg movement
      enemy.leftUpperLeg.rotation.x = Math.sin(enemy.walkCycle) * 0.4;
      enemy.leftLowerLeg.rotation.x = Math.sin(enemy.walkCycle) * 0.3;
      enemy.rightUpperLeg.rotation.x = -Math.sin(enemy.walkCycle) * 0.4;
      enemy.rightLowerLeg.rotation.x = -Math.sin(enemy.walkCycle) * 0.3;
      
      // Arm swinging
      enemy.leftUpperArm.rotation.x = -Math.sin(enemy.walkCycle) * 0.2;
      enemy.leftLowerArm.rotation.x = -Math.sin(enemy.walkCycle) * 0.15;
      enemy.rightUpperArm.rotation.x = Math.sin(enemy.walkCycle) * 0.2;
      enemy.rightLowerArm.rotation.x = Math.sin(enemy.walkCycle) * 0.15;
      
      // Body bobbing
      let baseHeight = 1;
      if (enemy.isBoss) {
        baseHeight = enemy.isDemonKing ? 2 : 1.5;
      }
      enemy.position.y = Math.sin(enemy.walkCycle * 2) * 0.05 + baseHeight;
    } else {
      // Reset to standing position
      enemy.leftUpperLeg.rotation.x = THREE.MathUtils.lerp(enemy.leftUpperLeg.rotation.x, 0, 0.1);
      enemy.leftLowerLeg.rotation.x = THREE.MathUtils.lerp(enemy.leftLowerLeg.rotation.x, 0, 0.1);
      enemy.rightUpperLeg.rotation.x = THREE.MathUtils.lerp(enemy.rightUpperLeg.rotation.x, 0, 0.1);
      enemy.rightLowerLeg.rotation.x = THREE.MathUtils.lerp(enemy.rightLowerLeg.rotation.x, 0, 0.1);
      enemy.leftUpperArm.rotation.x = THREE.MathUtils.lerp(enemy.leftUpperArm.rotation.x, 0, 0.1);
      enemy.leftLowerArm.rotation.x = THREE.MathUtils.lerp(enemy.leftLowerArm.rotation.x, 0, 0.1);
      enemy.rightUpperArm.rotation.x = THREE.MathUtils.lerp(enemy.rightUpperArm.rotation.x, 0, 0.1);
      enemy.rightLowerArm.rotation.x = THREE.MathUtils.lerp(enemy.rightLowerArm.rotation.x, 0, 0.1);
      
      let baseHeight = 1;
      if (enemy.isBoss) {
        baseHeight = enemy.isDemonKing ? 2 : 1.5;
      }
      enemy.position.y = THREE.MathUtils.lerp(enemy.position.y, baseHeight, 0.1);
    }
    
    enemy.prevX = enemy.position.x;
    enemy.prevZ = enemy.position.z;
    
    // State machine
    switch(enemy.state) {
      case 'patrol':
        if (!enemy.targetPosition || enemy.position.distanceTo(enemy.targetPosition) < 2) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 10 + Math.random() * 10;
          enemy.targetPosition = enemy.originalPosition.clone().add(
            new THREE.Vector3(Math.cos(angle) * distance, 0, Math.sin(angle) * distance)
          );
        }
        
        const patrolDirection = new THREE.Vector3();
        patrolDirection.subVectors(enemy.targetPosition, enemy.position);
        patrolDirection.y = 0;
        patrolDirection.normalize();
        
        const nextPos = enemy.position.clone().add(patrolDirection.multiplyScalar(enemy.speed));
        let collisionRadius = 0.5;
        if (enemy.isBoss) {
          collisionRadius = enemy.isDemonKing ? 1.2 : 0.8;
        }
        if (!checkCollision(nextPos.x, nextPos.z, collisionRadius)) {
          enemy.position.add(patrolDirection.multiplyScalar(enemy.speed));
        }
        
        enemy.rotation.y = Math.atan2(patrolDirection.x, patrolDirection.z);
        
        if (playerDistance < 30) {
          enemy.state = 'combat';
          enemy.lastStateChange = currentTime;
        }
        break;
        
      case 'combat':
        const direction = new THREE.Vector3();
        direction.subVectors(camera.position, enemy.position);
        direction.y = 0;
        direction.normalize();
        
        if (playerDistance > 15) {
          const nextPos = enemy.position.clone().add(direction.multiplyScalar(enemy.speed * 1.5));
          let collisionRadius = 0.5;
          if (enemy.isBoss) {
            collisionRadius = enemy.isDemonKing ? 1.2 : 0.8;
          }
          if (!checkCollision(nextPos.x, nextPos.z, collisionRadius)) {
            enemy.position.add(direction.multiplyScalar(enemy.speed * 1.5));
          }
        } else if (playerDistance < 10) {
          const nextPos = enemy.position.clone().add(direction.multiplyScalar(-enemy.speed));
          let collisionRadius = 0.5;
          if (enemy.isBoss) {
            collisionRadius = enemy.isDemonKing ? 1.2 : 0.8;
          }
          if (!checkCollision(nextPos.x, nextPos.z, collisionRadius)) {
            enemy.position.add(direction.multiplyScalar(-enemy.speed));
          }
        }
        
        enemy.rotation.y = Math.atan2(direction.x, direction.z);
        
        // Aim at player
        if (enemy.rightHand) {
          enemy.rightHand.rotation.x = -Math.atan2(
            camera.position.y - enemy.position.y - 1.5,
            playerDistance
          ) * 0.5;
        }
        
        if (playerDistance < enemy.shootingRange && currentTime - enemy.lastShotTime > enemy.fireRate) {
          // Demon King special attacks
          if (enemy.isDemonKing) {
            // Spawn minions periodically
            if (enemy.minionSpawnCooldown <= 0) {
              spawnDemonMinion(enemy.position);
              enemy.minionSpawnCooldown = 8000; // 8 seconds between minion spawns
            }
            
            // Fireball attack
            if (enemy.specialAttackCooldown <= 0 && Math.random() < 0.4) {
              // Multiple fireballs in a spread pattern
              for (let i = -2; i <= 2; i++) {
                const fireball = new THREE.Mesh(
                  new THREE.SphereGeometry(0.2, 8, 8), 
                  new THREE.MeshBasicMaterial({ color: 0xff3300 })
                );
                fireball.position.copy(enemy.position);
                fireball.position.y = 4;
                
                const fireballDirection = new THREE.Vector3();
                fireballDirection.subVectors(camera.position, enemy.position).normalize();
                fireballDirection.x += i * 0.15;
                fireballDirection.normalize();
                
                fireball.velocity = fireballDirection.multiplyScalar(0.6);
                fireball.isDemonKingProjectile = true;
                scene.add(fireball);
                enemyBullets.push(fireball);
              }
              enemy.specialAttackCooldown = 4000; // 4 seconds between special attacks
            } else {
              // Normal fireball attack
              const fireball = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8), 
                new THREE.MeshBasicMaterial({ color: 0xff6600 })
              );
              fireball.position.copy(enemy.position);
              fireball.position.y = 4;
              
              const fireballDirection = new THREE.Vector3();
              fireballDirection.subVectors(camera.position, enemy.position).normalize();
              fireball.velocity = fireballDirection.multiplyScalar(0.5);
              fireball.isDemonKingProjectile = true;
              scene.add(fireball);
              enemyBullets.push(fireball);
            }
          } 
          // Minion attack
          else if (enemy.isMinion) {
            const projectile = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 6, 6), 
              new THREE.MeshBasicMaterial({ color: 0xff9900 })
            );
            projectile.position.copy(enemy.position);
            projectile.position.y = 1.2;
            
            const projectileDirection = new THREE.Vector3();
            projectileDirection.subVectors(camera.position, enemy.position).normalize();
            projectile.velocity = projectileDirection.multiplyScalar(0.4);
            projectile.isMinionProjectile = true;
            scene.add(projectile);
            enemyBullets.push(projectile);
          }
          // Regular enemy attack
          else {
            const rocket = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, 0.3, 8), 
              new THREE.MeshBasicMaterial({ color: 0xff4500 })
            );
            rocket.position.copy(enemy.position);
            rocket.position.y = 2.5;
            const rocketDirection = new THREE.Vector3();
            rocketDirection.subVectors(camera.position, enemy.position).normalize();
            rocket.velocity = rocketDirection.multiplyScalar(0.4);
            rocket.rotation.z = Math.PI/2;
            scene.add(rocket);
            enemyBullets.push(rocket);
          }
          
          enemy.lastShotTime = currentTime;
        }
        
        if (playerDistance > 50) {
          enemy.state = 'patrol';
          enemy.lastStateChange = currentTime;
        }
        break;
    }
    
    // Update cooldowns
    if (enemy.specialAttackCooldown > 0) {
      enemy.specialAttackCooldown -= 16; // Approximate frame time
    }
    if (enemy.minionSpawnCooldown > 0) {
      enemy.minionSpawnCooldown -= 16;
    }
  }

  // --- GAME VARIABLES ---
  const playerModel = createRetroStylePlayerModel();
  scene.add(playerModel);
  
  // Only use PointerLockControls on desktop
  let controls;
  if (!isMobile) {
    controls = new PointerLockControls(camera, document.body);
  }
  
  let playerHealth = 100;
  const maxHealth = 100;
  const healthBar = document.getElementById('health-bar');
  const gameOverScreen = document.getElementById('game-over');
  let score = 0;
  let combo = 1;
  let lastKillTime = 0;
  const scoreDisplay = document.getElementById('score-display');
  const comboDisplay = document.getElementById('combo-display');
  const finalScoreDisplay = document.getElementById('final-score');
  let enemies = [];
  let enemyBullets = [];
  let bullets = [];
  let medikits = [];
  let playerMedikits = 0;
  let canShoot = true;
  let currentBoss = null;
  let demonKing = null;
  let isPaused = false; // Pause state
  const weapons = [
    { 
      name: 'Pistol', 
      fireRate: 300, 
      bulletSpeed: 2, 
      damage: 50, 
      color: 0xffff00,
      ammo: 999,
      reloadTime: 0,
      currentAmmo: 999,
      recoil: 5
    },
    { 
      name: 'Rifle', 
      fireRate: 100, 
      bulletSpeed: 4, 
      damage: 25, 
      color: 0xff0000,
      ammo: 30,
      reloadTime: 2000,
      currentAmmo: 30,
      recoil: 3,
      hasScope: true
    },
    { 
      name: 'Shotgun', 
      fireRate: 800, 
      bulletSpeed: 3, 
      damage: 100, 
      color: 0x00ff00,
      ammo: 8,
      reloadTime: 3000,
      currentAmmo: 8,
      recoil: 12
    },
    { 
      name: 'Rocket Launcher', 
      fireRate: 1500, 
      bulletSpeed: 1.5, 
      damage: 150, 
      color: 0xff00ff,
      ammo: 30,
      reloadTime: 4000,
      currentAmmo: 30,
      continuous: true,
      recoil: 15
    },
    { 
      name: 'Flamethrower', 
      fireRate: 50, 
      bulletSpeed: 0.8, 
      damage: 30, 
      color: 0xff8800,
      ammo: 100,
      reloadTime: 0,
      currentAmmo: 30,
      continuous: true,
      recoil: 2
    }
  ];
  let currentWeaponIndex = 0;
  const weaponDisplay = document.getElementById('weapon-display');
  const ammoDisplay = document.getElementById('ammo-display');
  const bossHealthContainer = document.getElementById('boss-health-container');
  const bossHealth = document.getElementById('boss-health');
  const bossName = document.getElementById('boss-name');
  const enemyCounter = document.getElementById('enemy-counter');
  const medikitCounter = document.getElementById('medikit-counter');
  
  // --- SCOPE VARIABLES ---
  let isScopedIn = false;
  const originalFov = camera.fov;
  const scopeFov = 50; // Zoomed-in Field of View

  // Wave system
  let currentWave = 1;
  let enemiesInWave = 5;
  let waveEnemiesSpawned = 0;
  let waveActive = true;
  
  // Weapon upgrade system
  const weaponUpgrades = {
    Pistol: [
      { name: "Extended Magazine", cost: 500, effect: () => { weapons[0].ammo += 50; weapons[0].currentAmmo += 50; }, purchased: false },
      { name: "Faster Reload", cost: 750, effect: () => { weapons[0].reloadTime *= 0.7; }, purchased: false },
      { name: "Increased Damage", cost: 1000, effect: () => { weapons[0].damage *= 1.5; }, purchased: false }
    ],
    Rifle: [
      { name: "Scope", cost: 600, effect: () => { weapons[1].bulletSpeed *= 1.3; }, purchased: false },
      { name: "Armor Piercing", cost: 900, effect: () => { weapons[1].damage *= 1.4; }, purchased: false },
      { name: "Extended Magazine", cost: 800, effect: () => { weapons[1].ammo += 20; weapons[1].currentAmmo += 20; }, purchased: false }
    ],
    Shotgun: [
      { name: "More Pellets", cost: 700, effect: () => { weapons[2].pelletCount = (weapons[2].pelletCount || 5) + 3; }, purchased: false },
      { name: "Faster Reload", cost: 1000, effect: () => { weapons[2].reloadTime *= 0.6; }, purchased: false },
      { name: "Increased Damage", cost: 1200, effect: () => { weapons[2].damage *= 1.3; }, purchased: false }
    ],
    "Rocket Launcher": [
      { name: "Faster Rockets", cost: 800, effect: () => { weapons[3].bulletSpeed *= 1.2; }, purchased: false },
      { name: "Bigger Explosion", cost: 1000, effect: () => { weapons[3].damage *= 1.5; }, purchased: false },
      { name: "Extra Rocket", cost: 600, effect: () => { weapons[3].ammo += 2; weapons[3].currentAmmo += 2; }, purchased: false }
    ],
    Flamethrower: [
      { name: "Longer Range", cost: 500, effect: () => { weapons[4].bulletSpeed *= 1.3; }, purchased: false },
      { name: "More Damage", cost: 700, effect: () => { weapons[4].damage *= 1.5; }, purchased: false },
      { name: "More Fuel", cost: 600, effect: () => { weapons[4].ammo += 50; weapons[4].currentAmmo += 50; }, purchased: false }
    ]
  };

  // --- MINIMAP SYSTEM ---
  const minimapCanvas = document.getElementById('minimap');
  const minimapCtx = minimapCanvas.getContext('2d');
  minimapCanvas.width = 200;
  minimapCanvas.height = 200;

  function updateMinimap() {
    // Clear canvas
    minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    minimapCtx.fillRect(0, 0, 200, 200);
    
    // Draw grid
    minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    minimapCtx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
      minimapCtx.beginPath();
      minimapCtx.moveTo(i * 20, 0);
      minimapCtx.lineTo(i * 20, 200);
      minimapCtx.stroke();
      
      minimapCtx.beginPath();
      minimapCtx.moveTo(0, i * 20);
      minimapCtx.lineTo(200, i * 20);
      minimapCtx.stroke();
    }
    
    // Draw player position
    const playerX = 100 + (camera.position.x / 5);
    const playerZ = 100 + (camera.position.z / 5);
    
    minimapCtx.fillStyle = '#00ff00';
    minimapCtx.beginPath();
    minimapCtx.arc(playerX, playerZ, 5, 0, Math.PI * 2);
    minimapCtx.fill();
    
    // Draw player view direction
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);
    const viewEndX = playerX + direction.x * 15;
    const viewEndZ = playerZ + direction.z * 15;
    
    minimapCtx.strokeStyle = '#00ff00';
    minimapCtx.lineWidth = 2;
    minimapCtx.beginPath();
    minimapCtx.moveTo(playerX, playerZ);
    minimapCtx.lineTo(viewEndX, viewEndZ);
    minimapCtx.stroke();
    
    // Draw enemy positions
    for (const enemy of enemies) {
      const enemyX = 100 + (enemy.position.x / 5);
      const enemyZ = 100 + (enemy.position.z / 5);
      
      minimapCtx.fillStyle = enemy.isDemonKing ? '#ff00ff' : (enemy.isMinion ? '#ff8800' : '#ff0000');
      minimapCtx.beginPath();
      if (enemy.isDemonKing) {
        minimapCtx.arc(enemyX, enemyZ, 8, 0, Math.PI * 2); // Boss is larger
      } else if (enemy.isMinion) {
        minimapCtx.arc(enemyX, enemyZ, 3, 0, Math.PI * 2); // Minions are smaller
      } else {
        minimapCtx.arc(enemyX, enemyZ, 5, 0, Math.PI * 2);
      }
      minimapCtx.fill();
    }
    
    // Draw medikit positions
    minimapCtx.fillStyle = '#00ffff';
    for (const medikit of medikits) {
      const medikitX = 100 + (medikit.position.x / 5);
      const medikitZ = 100 + (medikit.position.z / 5);
      
      minimapCtx.fillRect(medikitX - 3, medikitZ - 3, 6, 6);
    }
  }

  // --- VISUAL EFFECTS ---
  function createExplosion(position, size = 1) {
    const particleCount = 30 * size;
    const explosionLight = new THREE.PointLight(0xff4500, 2 * size, 10 * size);
    explosionLight.position.copy(position);
    scene.add(explosionLight);
    
    for (let i = 0; i < particleCount; i++) {
      const particle = new THREE.Mesh(
        new THREE.SphereGeometry(0.1 * size + Math.random() * 0.3 * size, 8, 8),
        new THREE.MeshBasicMaterial({ 
          color: new THREE.Color().setHSL(0.05 + Math.random() * 0.1, 1, 0.5 + Math.random() * 0.5)
        })
      );
      particle.position.copy(position);
      
      const velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 1.2 * size,
        Math.random() * 1.2 * size,
        (Math.random() - 0.5) * 1.2 * size
      );
      
      particle.velocity = velocity;
      particle.lifetime = 20 + Math.random() * 20;
      scene.add(particle);
      
      // Update particles
      const updateParticle = () => {
        particle.position.add(particle.velocity);
        particle.velocity.y -= 0.05;
        particle.lifetime--;
        particle.material.opacity = particle.lifetime / 40;
        
        if (particle.lifetime <= 0) {
          scene.remove(particle);
        } else {
          requestAnimationFrame(updateParticle);
        }
      };
      updateParticle();
    }
    
    // Remove explosion light
    setTimeout(() => {
      scene.remove(explosionLight);
    }, 500);
  }

  function createHitEffect(position, color = 0xffff00) {
    const particleCount = 15;
    
    for (let i = 0; i < particleCount; i++) {
      const particle = new THREE.Mesh(
        new THREE.SphereGeometry(0.1 + Math.random() * 0.2, 8, 8),
        new THREE.MeshBasicMaterial({ 
          color: new THREE.Color(color)
        })
      );
      particle.position.copy(position);
      
      const velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.8,
        Math.random() * 0.8,
        (Math.random() - 0.5) * 0.8
      );
      
      particle.velocity = velocity;
      particle.lifetime = 15 + Math.random() * 15;
      scene.add(particle);
      
      // Update particles
      const updateParticle = () => {
        particle.position.add(particle.velocity);
        particle.velocity.y -= 0.02;
        particle.lifetime--;
        particle.material.opacity = particle.lifetime / 30;
        
        if (particle.lifetime <= 0) {
          scene.remove(particle);
        } else {
          requestAnimationFrame(updateParticle);
        }
      };
      updateParticle();
    }
  }

  // --- INITIALIZATION ---
  createVillage();

  // --- MEDIKIT SPAWNING ---
  function spawnMedikit() {
    let spawnPosition;
    let attempts = 0;
    do {
      spawnPosition = {
        x: (Math.random() - 0.5) * 180,
        z: (Math.random() - 0.5) * 180
      };
      attempts++;
    } while (checkCollision(spawnPosition.x, spawnPosition.z) && attempts < 50);
    
    if (attempts < 50) {
      const medikit = createMedikitModel();
      medikit.position.set(spawnPosition.x, 0.5, spawnPosition.z);
      scene.add(medikit);
      medikits.push(medikit);
    }
  }

  // --- ENEMY SPAWNING ---
  function createEnemy() {
    let spawnPosition;
    let attempts = 0;
    do {
      spawnPosition = {
        x: (Math.random() - 0.5) * 150,
        z: (Math.random() - 0.5) * 150
      };
      attempts++;
    } while (checkCollision(spawnPosition.x, spawnPosition.z) && attempts < 50);
    
    if (attempts < 50) {
      const enemy = createRealisticEnemyModel();
      enemy.position.set(spawnPosition.x, 1, spawnPosition.z);
      enemy.originalPosition = enemy.position.clone();
      scene.add(enemy);
      enemies.push(enemy);
      waveEnemiesSpawned++;
    }
  }

  function spawnDemonMinion(bossPosition) {
    if (!demonKing) return;
    
    // Spawn minions around the demon king
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * Math.PI * 2;
      const distance = 5 + Math.random() * 3;
      
      const minion = createDemonMinionModel();
      minion.position.set(
        bossPosition.x + Math.cos(angle) * distance,
        0.7,
        bossPosition.z + Math.sin(angle) * distance
      );
      minion.originalPosition = minion.position.clone();
      scene.add(minion);
      enemies.push(minion);
    }
  }

  function createDemonKing() {
    if (demonKing) return; // Only one demon king at a time
    
    let spawnPosition;
    let attempts = 0;
    do {
      spawnPosition = {
        x: (Math.random() - 0.5) * 100,
        z: (Math.random() - 0.5) * 100
      };
      attempts++;
    } while (checkCollision(spawnPosition.x, spawnPosition.z, 1.2) && attempts < 50);
    
    if (attempts < 50) {
      const boss = createDemonKingModel();
      boss.position.set(spawnPosition.x, 2, spawnPosition.z);
      boss.originalPosition = boss.position.clone();
      scene.add(boss);
      enemies.push(boss);
      demonKing = boss;
      currentBoss = boss;
      
      // Show boss UI
      bossName.textContent = "DEMON KING";
      bossName.style.display = 'block';
      bossHealthContainer.style.display = 'block';
      updateBossHealthUI();
      
      // Spawn initial minions
      spawnDemonMinion(boss.position);
      
      // Show story when boss appears
      showStoryMessage("The Demon King has arrived! Defend the village at all costs!");
    }
  }

  function updateBossHealthUI() {
    if (currentBoss) {
      const healthPercent = Math.max(0, currentBoss.health / currentBoss.maxHealth);
      bossHealth.style.width = (healthPercent * 100) + '%';
    }
  }

  function updateEnemyCounter() {
    const regularEnemies = enemies.filter(e => !e.isBoss && !e.isMinion).length;
    const minions = enemies.filter(e => e.isMinion).length;
    const bossCount = currentBoss ? 1 : 0;
    
    let counterText = `Enemies: ${regularEnemies}`;
    if (minions > 0) {
      counterText += ` + ${minions} Minions`;
    }
    if (bossCount > 0) {
      counterText += ` + 1 DEMON KING`;
      enemyCounter.style.color = '#ff0000';
    } else {
      enemyCounter.style.color = 'white';
    }
    
    enemyCounter.textContent = counterText;
  }

  function updateMedikitCounter() {
    medikitCounter.textContent = `Medikits: ${playerMedikits}`;
  }

  function updateAmmoDisplay() {
    const weapon = weapons[currentWeaponIndex];
    if (weapon.ammo === 999) {
      ammoDisplay.textContent = "Ammo: ∞";
    } else {
      ammoDisplay.textContent = `Ammo: ${weapon.currentAmmo}/${weapon.ammo}`;
    }
  }

  function showStoryNotification(message) {
    const notification = document.createElement('div');
    notification.className = 'story-notification';
    notification.textContent = message;
    notification.style.position = 'absolute';
    notification.style.top = '140px';
    notification.style.left = '50%';
    notification.style.transform = 'translateX(-50%)';
    notification.style.color = '#ffaa00';
    notification.style.fontSize = '18px';
    notification.style.fontWeight = 'bold';
    notification.style.textShadow = '2px 2px 0 #000';
    notification.style.padding = '10px 20px';
    notification.style.border = '2px solid #ff6b35';
    notification.style.borderRadius = '10px';
    notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    notification.style.zIndex = '200';
    notification.style.pointerEvents = 'none';
    notification.style.textAlign = 'center';
    document.body.appendChild(notification);
    
    setTimeout(() => {
      document.body.removeChild(notification);
    }, 3000);
  }

  function showStoryMessage(message) {
    if (storyDisplay.style.display !== 'block') {
      storyDisplay.textContent = message;
      storyDisplay.style.display = 'block';
      
      setTimeout(() => {
        storyDisplay.style.display = 'none';
      }, 3000);
    }
  }

  function showWaveMessage(waveNumber) {
    waveDisplay.textContent = `WAVE ${waveNumber}`;
    waveDisplay.style.display = 'block';
    
    setTimeout(() => {
      waveDisplay.style.display = 'none';
    }, 3000);
  }

  // --- WAVE SYSTEM ---
  function startNextWave() {
    currentWave++;
    enemiesInWave = 5 + currentWave * 3;
    waveEnemiesSpawned = 0;
    waveActive = true;
    
    showWaveMessage(currentWave);
    showStoryNotification(`Wave ${currentWave} incoming! ${enemiesInWave} enemies approaching!`);
    
    // Spawn boss every 5 waves
    if (currentWave % 5 === 0 && !demonKing) {
      setTimeout(() => {
        createDemonKing();
      }, 2000);
    }
    
    // Increase difficulty
    if (currentWave > 5 && Math.random() < 0.3) {
      setTimeout(() => {
        for (let i = 0; i < Math.min(3, Math.floor(currentWave / 5)); i++) {
          const minion = createDemonMinionModel();
          minion.position.set(
            (Math.random() - 0.5) * 100,
            0.7,
            (Math.random() - 0.5) * 100
          );
          minion.originalPosition = minion.position.clone();
          scene.add(minion);
          enemies.push(minion);
          waveEnemiesSpawned++;
        }
      }, 3000);
    }
  }

  // --- UPGRADE SHOP ---
  function openUpgradeShop() {
    const shop = document.getElementById('upgrade-shop');
    const upgradeList = document.getElementById('upgrade-list');
    
    // Clear previous content
    upgradeList.innerHTML = '';
    
    // Generate upgrade items
    const currentWeapon = weapons[currentWeaponIndex];
    const weaponName = currentWeapon.name;
    const upgrades = weaponUpgrades[weaponName];
    
    if (upgrades) {
      upgrades.forEach((upgrade, index) => {
        const upgradeItem = document.createElement('div');
        upgradeItem.className = 'upgrade-item';
        
        const upgradeInfo = document.createElement('div');
        upgradeInfo.innerHTML = `<strong>${upgrade.name}</strong> - Cost: ${upgrade.cost}`;
        
        const upgradeButton = document.createElement('button');
        upgradeButton.className = 'upgrade-button';
        upgradeButton.textContent = upgrade.purchased ? 'PURCHASED' : 'BUY';
        upgradeButton.disabled = upgrade.purchased || score < upgrade.cost;
        
        if (!upgrade.purchased) {
          upgradeButton.addEventListener('click', () => {
            if (score >= upgrade.cost) {
              score -= upgrade.cost;
              updateScore(0);
              upgrade.effect();
              upgrade.purchased = true;
              upgradeButton.textContent = 'PURCHASED';
              upgradeButton.disabled = true;
              showStoryNotification(`${upgrade.name} purchased!`);
            }
          });
        }
        
        upgradeItem.appendChild(upgradeInfo);
        upgradeItem.appendChild(upgradeButton);
        upgradeList.appendChild(upgradeItem);
      });
    } else {
      upgradeList.innerHTML = '<p>No upgrades available for this weapon.</p>';
    }
    
    shop.style.display = 'block';
  }

  function closeUpgradeShop() {
    document.getElementById('upgrade-shop').style.display = 'none';
  }

  // --- GAME FUNCTIONS ---
  function updateHealthUI() { 
    const healthPercent = Math.max(0, playerHealth / maxHealth); 
    healthBar.style.width = (healthPercent * 100) + '%'; 
    if (healthPercent > 0.6) healthBar.style.backgroundColor = '#4CAF50'; 
    else if (healthPercent > 0.3) healthBar.style.backgroundColor = '#ff9800'; 
    else healthBar.style.backgroundColor = '#f44336'; 
  }

  function useMedikit() {
    if (playerMedikits > 0 && playerHealth < maxHealth) {
      playerMedikits--;
      const healAmount = 50;
      playerHealth = Math.min(playerHealth + healAmount, maxHealth);
      updateHealthUI();
      updateMedikitCounter();
      showStoryNotification("+50 HEALTH");
      
      // Visual effect
      const healEffect = new THREE.PointLight(0x00ff00, 1, 5);
      healEffect.position.copy(camera.position);
      scene.add(healEffect);
      setTimeout(() => {
        scene.remove(healEffect);
      }, 500);
    } else if (playerMedikits <= 0) {
      showStoryNotification("No medikits remaining! Find more on the battlefield.");
    }
  }

  function takeDamage(amount) { 
    playerHealth -= amount; 
    updateHealthUI(); 
    
    // Screen shake effect
    const shakeAmount = amount / 10;
    camera.position.x += (Math.random() - 0.5) * shakeAmount;
    camera.position.y += (Math.random() - 0.5) * shakeAmount;
    
    if (playerHealth <= 0) { 
      playerHealth = 0; 
      gameOverScreen.style.display = 'block'; 
      finalScoreDisplay.textContent = `Final Score: ${score}`; 
      finalScoreDisplay.style.display = 'block'; 
      
      if (controls) {
        controls.unlock(); 
      }
      isPaused = true; // Pause the game on game over
      
      const restartButton = document.createElement('button');
      restartButton.textContent = 'RESTART';
      restartButton.style.position = 'absolute';
      restartButton.style.top = '70%';
      restartButton.style.left = '50%';
      restartButton.style.transform = 'translate(-50%, -50%)';
      restartButton.style.padding = '10px 20px';
      restartButton.style.fontSize = '20px';
      restartButton.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
      restartButton.style.border = 'none';
      restartButton.style.borderRadius = '5px';
      restartButton.style.cursor = 'pointer';
      restartButton.style.zIndex = '300';
      restartButton.addEventListener('click', () => {
        location.reload();
      });
      document.body.appendChild(restartButton);
      
      // Show game over story
      showStoryMessage("The village has fallen to darkness... The Demon King reigns supreme.");
    } 
  }

  function updateScore(points) {
    const currentTime = Date.now();
    if (currentTime - lastKillTime < 2000) {
      combo = Math.min(combo + 0.5, 5);
    } else {
      combo = 1;
    }
    lastKillTime = currentTime;
    
    score += Math.floor(points * combo);
    scoreDisplay.textContent = `Score: ${score}`;
    comboDisplay.textContent = `Combo: x${combo.toFixed(1)}`;
    
    const popup = document.createElement('div');
    popup.className = 'hit-popup';
    popup.textContent = `+${Math.floor(points * combo)}`;
    popup.style.left = '50%';
    popup.style.top = '40%';
    document.body.appendChild(popup);
    
    setTimeout(() => {
      document.body.removeChild(popup);
    }, 1000);
  }

  // --- 2D GUN SWAY AND RECOIL ---
  let gunRecoil = 0;
  let targetGunRotation = { x: 0, y: 0 };
  let currentGunRotation = { x: 0, y: 0 };
  
  function switchWeaponUI(newIndex) {
    // Hide all weapon images
    weaponImages.forEach(img => img.style.display = 'none');

    // Show the new weapon image
    if (weaponImages[newIndex]) {
      weaponImages[newIndex].style.display = 'block';
    }

    // --- SCOPE LOGIC ---
    // Exit scope if the new weapon doesn't have one
    if (!weapons[newIndex].hasScope && isScopedIn) {
        isScopedIn = false;
        updateScopeState();
    }
    
    // Update muzzle flash position for the new weapon
    updateMuzzleFlashPosition(newIndex);
  }
  
  // Function to update muzzle flash position with precise barrel positioning
  function updateMuzzleFlashPosition(weaponIndex) {
    const weaponNames = ['pistol', 'shotgun', 'rifle', 'rocketLauncher', 'flamethrower'];
    const currentWeaponName = weaponNames[weaponIndex];
    const position = muzzleFlashPositions[currentWeaponName];
    
    if (position) {
      // Set the position relative to the current weapon's barrel
      const weaponImg = weaponImages[weaponIndex];
      if (weaponImg) {
        const imgRect = weaponImg.getBoundingClientRect();
        
        // Calculate the precise muzzle position based on percentage
        const muzzleX = imgRect.left + (imgRect.width * position.xPercent / 100);
        const muzzleY = imgRect.top + (imgRect.height * position.yPercent / 100);
        
        // Apply any additional offsets for fine-tuning
        const finalX = muzzleX + position.offsetX;
        const finalY = muzzleY + position.offsetY;
        
        // Position the muzzle flash at the calculated location
        muzzleFlashElement.style.left = `${finalX}px`;
        muzzleFlashElement.style.top = `${finalY}px`;
        
        // Scale the muzzle flash based on weapon type
        muzzleFlashElement.style.transform = `translate(-50%, -50%) scale(${position.scale})`;
        
        // Add pulsing animation class for realistic effect
        muzzleFlashElement.classList.add('muzzle-active');
      }
    }
  }

  function updateScopeState() {
    if (isScopedIn) {
        crosshair.style.opacity = '0';
        scopeDot.style.display = 'block';
        weaponContainer.style.opacity = '0';
    } else {
        crosshair.style.opacity = '1';
        scopeDot.style.display = 'none';
        weaponContainer.style.opacity = '1';
    }
  }

  function togglePauseMenu() {
    if (playerHealth <= 0) return; // Don't pause if game is over

    isPaused = !isPaused;

    if (isPaused) {
      // Pausing
      pauseMenu.style.display = 'flex';
      if (controls) {
        controls.unlock(); // Unlock mouse to interact with menu
      }
    } else {
      // Resuming
      pauseMenu.style.display = 'none';
      if (controls) {
        controls.lock(); // Re-lock mouse for gameplay
      }
    }
  }

  function shoot() { 
    if (!canShoot) return; 
    
    const weapon = weapons[currentWeaponIndex];
    
    // Check ammo
    if (weapon.ammo !== 999 && weapon.currentAmmo <= 0) {
      showStoryNotification("Out of ammo! Press R to reload or switch weapons.");
      return;
    }
    
    // Consume ammo
    if (weapon.ammo !== 999) {
      weapon.currentAmmo--;
      updateAmmoDisplay();
    }
    
    // --- 2D GUN RECOIL ---
    gunRecoil = weapon.recoil; // Use recoil from weapon object

    // --- 2D MUZZLE FLASH AT PRECISE BARREL POSITION ---
    // Update muzzle flash position before showing it
    updateMuzzleFlashPosition(currentWeaponIndex);
    muzzleFlashElement.style.display = 'block';
    
    // Create a brief light effect at the muzzle position
    const muzzleLight = new THREE.PointLight(0xffffff, 1.5, 8);
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);
    muzzleLight.position.copy(camera.position);
    muzzleLight.position.add(direction.multiplyScalar(2));
    scene.add(muzzleLight);
    
    // Add screen flash effect for more realism
    const screenFlash = document.createElement('div');
    screenFlash.style.position = 'fixed';
    screenFlash.style.top = '0';
    screenFlash.style.left = '0';
    screenFlash.style.width = '100%';
    screenFlash.style.height = '100%';
    screenFlash.style.backgroundColor = 'rgba(255, 255, 200, 0.1)';
    screenFlash.style.pointerEvents = 'none';
    screenFlash.style.zIndex = '15';
    document.body.appendChild(screenFlash);
    
    // Hide muzzle flash, remove light and screen flash after a short duration
    setTimeout(() => {
        muzzleFlashElement.style.display = 'none';
        muzzleFlashElement.classList.remove('muzzle-active');
        scene.remove(muzzleLight);
        if (document.body.contains(screenFlash)) {
          document.body.removeChild(screenFlash);
        }
    }, 50); 
    
    const pelletCount = weapon.name === 'Shotgun' ? (weapon.pelletCount || 5) : 1; 
    const spreadAngle = 0.05; 
    
    for (let i = 0; i < pelletCount; i++) { 
      const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: weapon.color })); 
      bullet.position.copy(camera.position); 
      const direction = new THREE.Vector3(); 
      camera.getWorldDirection(direction); 
      if (pelletCount > 1) { 
        direction.x += (Math.random() - 0.5) * spreadAngle; 
        direction.y += (Math.random() - 0.5) * spreadAngle; 
        direction.normalize(); 
      } 
      bullet.velocity = direction.multiplyScalar(weapon.bulletSpeed); 
      bullet.damage = weapon.damage; 
      bullet.isExplosive = weapon.explosive || false;
      scene.add(bullet); 
      bullets.push(bullet); 
    } 
    
    canShoot = false; 
    setTimeout(() => { 
      canShoot = true; 
    }, weapon.fireRate); 
  }

  function reloadWeapon() {
    const weapon = weapons[currentWeaponIndex];
    if (weapon.ammo === 999 || weapon.currentAmmo === weapon.ammo || weapon.reloadTime === 0) {
      return;
    }
    
    canShoot = false;
    showStoryNotification("Reloading...");
    
    setTimeout(() => {
      weapon.currentAmmo = weapon.ammo;
      updateAmmoDisplay();
      canShoot = true;
      showStoryNotification("Reloaded!");
    }, weapon.reloadTime);
  }

  function updateWeaponDisplay() { 
    weaponDisplay.textContent = `Weapon: ${weapons[currentWeaponIndex].name}`; 
    updateAmmoDisplay();
  }

  // --- EVENT LISTENERS ---
  document.getElementById('instructions').addEventListener('click', () => { 
    playerHealth = maxHealth; 
    score = 0;
    combo = 1;
    playerMedikits = 3;
    currentWave = 1;
    enemiesInWave = 5;
    waveEnemiesSpawned = 0;
    waveActive = true;
    updateHealthUI(); 
    updateScore(0);
    updateMedikitCounter();
    updateWeaponDisplay();
    gameOverScreen.style.display = 'none';
    finalScoreDisplay.style.display = 'none';
    
    if (controls) {
      controls.lock(); 
    }
    showStoryMessage("The village needs your help! Defend it from the demonic invasion!");
    showWaveMessage(currentWave);
    
    // Show 2D gun when game starts
    weaponContainer.style.display = 'block';
    switchWeaponUI(currentWeaponIndex); // Show the initial weapon
  }); 
  
  // Desktop mouse controls
  if (!isMobile) {
    document.addEventListener('mousedown', (event) => { 
      if (event.button === 0 && controls && controls.isLocked) { 
        shoot(); 
      } 
    });
    
    document.addEventListener('keydown', (e) => { 
      if (e.code === 'Digit1') { 
        currentWeaponIndex = 0; 
        updateWeaponDisplay();
        switchWeaponUI(currentWeaponIndex);
      } 
      if (e.code === 'Digit2') { 
        currentWeaponIndex = 1; 
        updateWeaponDisplay();
        switchWeaponUI(currentWeaponIndex);
      } 
      if (e.code === 'Digit3') { 
        currentWeaponIndex = 2; 
        updateWeaponDisplay();
        switchWeaponUI(currentWeaponIndex);
      } 
      if (e.code === 'Digit4') { 
        currentWeaponIndex = 3; 
        updateWeaponDisplay();
        switchWeaponUI(currentWeaponIndex);
      } 
      if (e.code === 'Digit5') { 
        currentWeaponIndex = 4; 
        updateWeaponDisplay();
        switchWeaponUI(currentWeaponIndex);
      } 
      if (e.code === 'KeyE') { useMedikit(); } 
      if (e.code === 'KeyR') { reloadWeapon(); }
      if (e.code === 'KeyB') { 
        if (!isPaused) openUpgradeShop();
      }
      if (e.code === 'Escape') {
        togglePauseMenu();
      }
    });
  }
  
  // Shop close button
  document.getElementById('close-shop').addEventListener('click', closeUpgradeShop);
  
  const keys = {}; 
  if (!isMobile) {
    document.addEventListener("keydown", e => keys[e.code] = true); 
    document.addEventListener("keyup", e => keys[e.code] = false);
  }

  // --- PAUSE MENU BUTTON LISTENERS ---
  resumeButton.addEventListener('click', () => {
    togglePauseMenu();
  });

  newGameButton.addEventListener('click', () => {
    location.reload();
  });

  quitButton.addEventListener('click', () => {
    // Note: window.close() works best if the script opened the window.
    // For tabs opened manually, the browser may block this.
    window.close();
  });
  
  // --- STORY PROGRESSION ---
  let currentChapter = 1;
  let demonKingFirstAppearance = false;
  let bossDefeated = false;

  function checkStoryProgression() {
    // Chapter 1: Beginning (0-200 score)
    if (score >= 200 && currentChapter === 1) {
      currentChapter = 2;
      showStoryMessage("Chapter 2: The Invasion Begins - More enemies are arriving!");
    }
    
    // Chapter 2: Mid game (500-1000 score)
    if (score >= 500 && currentChapter === 2) {
      currentChapter = 3;
      showStoryMessage("Chapter 3: The Demon King Approaches - The ultimate evil draws near!");
    }
    
    // Chapter 3: Boss fight (1500+ score)
    if (score >= 1500 && currentChapter === 3) {
      currentChapter = 4;
      showStoryMessage("Chapter 4: Final Battle - Destroy the Demon King and save Oakhaven!");
    }
    
    // Victory
    if (bossDefeated) {
      currentChapter = 5;
      showStoryMessage("VICTORY! Oakhaven is saved! The darkness has been driven back to the underworld!");
    }
  }

  // --- ANIMATION LOOP ---
  const moveSpeed = 0.3; 
  let lastDamageTime = 0;
  let bossSpawnTimer = 0;
  let enemySpawnTimer = 0;
  let medikitSpawnTimer = 0;
  let waveSpawnTimer = 0;
  let mobileLookSpeed = 0.002; // Sensitivity for mobile look controls
  
  function animate() {
    requestAnimationFrame(animate);
    
    // Only run game logic if not paused
    if (!isPaused) {
      // Handle mobile movement
      if (isMobile && joystickActive) {
        // Normalize joystick position
        const maxDistance = 35; // Half the joystick base radius
        const normalizedX = joystickPosition.x / maxDistance;
        const normalizedY = joystickPosition.y / maxDistance;
        
        // Calculate movement direction
        const moveVector = new THREE.Vector3();
        const forward = new THREE.Vector3(); 
        const right = new THREE.Vector3();
        camera.getWorldDirection(forward); 
        forward.y = 0; 
        forward.normalize();
        right.crossVectors(forward, camera.up);
        
        // Apply joystick input to movement
        if (Math.abs(normalizedX) > 0.1 || Math.abs(normalizedY) > 0.1) {
          moveVector.add(forward.multiplyScalar(-normalizedY));
          moveVector.add(right.multiplyScalar(normalizedX));
          
          if (moveVector.length() > 0) {
            moveVector.normalize();
            const nextPos = camera.position.clone().add(moveVector.multiplyScalar(moveSpeed));
            
            // Enhanced collision detection for player
            if (!checkCollision(nextPos.x, nextPos.z)) {
              camera.position.copy(nextPos);
            }
          }
        }
      }
      
      // Handle desktop movement
      if (!isMobile && controls && controls.isLocked) {
        const moveVector = new THREE.Vector3(); 
        const forward = new THREE.Vector3(); 
        const right = new THREE.Vector3();
        camera.getWorldDirection(forward); 
        forward.y = 0; 
        forward.normalize();
        right.crossVectors(forward, camera.up);
        if (keys["KeyW"]) moveVector.add(forward); 
        if (keys["KeyS"]) moveVector.sub(forward); 
        if (keys["KeyA"]) moveVector.sub(right); 
        if (keys["KeyD"]) moveVector.add(right);
        
        if (moveVector.length() > 0) {
          moveVector.normalize();
          const nextPos = camera.position.clone().add(moveVector.multiplyScalar(moveSpeed));
          
          // Enhanced collision detection for player
          if (!checkCollision(nextPos.x, nextPos.z)) {
            camera.position.copy(nextPos);
          }
        }
      }
      
      // Handle mobile look controls
      if (isMobile) {
        // Apply touch delta to camera rotation
        if (touchDeltaX !== 0 || touchDeltaY !== 0) {
          // Horizontal rotation (around Y axis)
          camera.rotation.y -= touchDeltaX * mobileLookSpeed;
          
          // Vertical rotation (around X axis)
          const newRotationX = camera.rotation.x - touchDeltaY * mobileLookSpeed;
          // Clamp vertical rotation to prevent over-rotation
          camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, newRotationX));
          
          // Reset touch delta after applying
          touchDeltaX = 0;
          touchDeltaY = 0;
        }
      }
      
      // --- 2D GUN SWAY AND RECOIL UPDATE ---
      if (!isScopedIn) {
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        
        targetGunRotation.y = -cameraDirection.x * 0.05; // Horizontal sway
        targetGunRotation.x = -cameraDirection.y * 0.05; // Vertical sway

        // Apply recoil
        if (gunRecoil > 0) {
          targetGunRotation.x -= gunRecoil * 0.5;
          gunRecoil *= 0.9; // Smoothly reduce recoil
        }

        // Smoothly interpolate to target rotation
        currentGunRotation.x += (targetGunRotation.x - currentGunRotation.x) * 0.1;
        currentGunRotation.y += (targetGunRotation.y - currentGunRotation.y) * 0.1;

        // Apply the transformation to the 2D gun container
        weaponContainer.style.transform = `
          translateX(-50%) 
          translateY(${currentGunRotation.x}px) 
          rotateX(${currentGunRotation.x}deg) 
          rotateY(${currentGunRotation.y}deg)
        `;
      }

      // --- SMOOTH ZOOM ---
      const targetFov = isScopedIn ? scopeFov : originalFov;
      camera.fov += (targetFov - camera.fov) * 0.1; // Smooth transition

      const currentTime = Date.now();
      
      for (const enemy of enemies) {
        updateEnemyAI(enemy, currentTime);
      }
      
      // Handle mobile shooting
      if (isMobile && fireButtonPressed && canShoot) {
        shoot();
      }
      
      // Wave system
      if (waveActive && waveEnemiesSpawned < enemiesInWave) {
        waveSpawnTimer += 16;
        if (waveSpawnTimer > 2000) { // Spawn enemy every 2 seconds
          createEnemy();
          waveSpawnTimer = 0;
        }
      }
      
      // Check for wave completion
      if (waveActive && waveEnemiesSpawned >= enemiesInWave) {
        const remainingEnemies = enemies.filter(e => !e.isBoss && !e.isMinion).length;
        if (remainingEnemies === 0) {
          waveActive = false;
          showStoryNotification(`Wave ${currentWave} complete! Prepare for the next wave...`);
          setTimeout(() => {
            startNextWave();
          }, 5000);
        }
      }
      
      // Spawn demon king periodically
      bossSpawnTimer += 16;
      if (!demonKing && bossSpawnTimer > 25000) {
        if (!demonKingFirstAppearance) {
          demonKingFirstAppearance = true;
          showStoryMessage("The Demon King Malphas has arrived! The ultimate evil threatens Oakhaven!");
        }
        createDemonKing();
        bossSpawnTimer = 0;
      }
      
      // Spawn medikits periodically
      medikitSpawnTimer += 16;
      if (medikits.length < 20 && medikitSpawnTimer > 3000) { // Spawn medikit every 3 seconds
        spawnMedikit();
        medikitSpawnTimer = 0;
      }
      
      // Update counters
      updateEnemyCounter();
      updateMedikitCounter();
      
      // Check story progression
      checkStoryProgression();
    }
    
    // Update minimap
    updateMinimap();
    
    // Update medikits
    for (let i = medikits.length - 1; i >= 0; i--) {
      const medikit = medikits[i];
      
      // Floating animation
      medikit.position.y = 0.5 + Math.sin(Date.now() * 0.001 + medikit.floatOffset) * 0.2;
      medikit.rotation.y += medikit.rotationSpeed;
      
      // Check pickup
      const distance = camera.position.distanceTo(medikit.position);
      if (distance < 2) {
        playerMedikits++;
        scene.remove(medikit);
        medikits.splice(i, 1);
        showStoryNotification("+1 MEDIKIT");
        updateMedikitCounter();
      }
    }
    
    // Update bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const bullet = bullets[i];
      bullet.position.add(bullet.velocity);
      
      for (let j = enemies.length - 1; j >= 0; j--) {
        const enemy = enemies[j];
        let hitRadius = 1.5;
        
        if (enemy.isDemonKing) {
          hitRadius = 3.0; // Bigger hit radius for demon king
        } else if (enemy.isMinion) {
          hitRadius = 1.0; // Smaller hit radius for minions
        } else if (enemy.isBoss) {
          hitRadius = 2.0; // Regular boss hit radius
        }
        
        if (bullet.position.distanceTo(enemy.position) < hitRadius) {
          createHitEffect(enemy.position, bullet.material.color.getHex());
          
          // Explosive damage
          if (bullet.isExplosive) {
            createExplosion(bullet.position, 1.5);
            
            // Area damage
            for (const otherEnemy of enemies) {
              if (otherEnemy !== enemy && bullet.position.distanceTo(otherEnemy.position) < 5) {
                otherEnemy.health -= bullet.damage * 0.5;
                createHitEffect(otherEnemy.position, 0xff8800);
              }
            }
          }
          
          if (enemy.isDemonKing) {
            enemy.health -= bullet.damage;
            updateBossHealthUI();
            
            if (enemy.health <= 0) {
              createExplosion(enemy.position, 2);
              scene.remove(enemy);
              enemies.splice(j, 1);
              updateScore(1000); // Demon king gives more points
              demonKing = null;
              currentBoss = null;
              bossName.style.display = 'none';
              bossHealthContainer.style.display = 'none';
              bossDefeated = true;
              showStoryMessage("The Demon King has been defeated! But his evil influence may return...");
            }
          } else if (enemy.isMinion) {
            enemy.health -= bullet.damage;
            
            if (enemy.health <= 0) {
              createExplosion(enemy.position, 0.5);
              scene.remove(enemy);
              enemies.splice(j, 1);
              updateScore(50); // Minions give fewer points
            }
          } else if (enemy.isBoss) {
            enemy.health -= bullet.damage;
            
            if (enemy.health <= 0) {
              createExplosion(enemy.position, 1);
              scene.remove(enemy);
              enemies.splice(j, 1);
              updateScore(500);
              currentBoss = null;
              bossName.style.display = 'none';
              bossHealthContainer.style.display = 'none';
            }
          } else {
            createExplosion(enemy.position, 0.5);
            scene.remove(enemy);
            enemies.splice(j, 1);
            updateScore(100);
          }
          
          scene.remove(bullet);
          bullets.splice(i, 1);
          break;
        }
      }
      
      if (bullet && bullet.position.length() > 100) {
        scene.remove(bullet);
        bullets.splice(i, 1);
      }
    }
    
    // Update enemy bullets
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const bullet = enemyBullets[i];
      bullet.position.add(bullet.velocity);
      
      if (bullet.position.distanceTo(camera.position) < 1) {
        let damage = 15;
        
        if (bullet.isDemonKingProjectile) {
          damage = 30; // Demon king projectiles do more damage
          createExplosion(bullet.position, 0.5);
        } else if (bullet.isMinionProjectile) {
          damage = 10; // Minion projectiles do less damage
        }
        
        takeDamage(damage);
        scene.remove(bullet);
        enemyBullets.splice(i, 1);
      } else if (bullet.position.length() > 100) {
        scene.remove(bullet);
        enemyBullets.splice(i, 1);
      }
    }
    
    // Melee damage
    const currentTime = Date.now();
    for (const enemy of enemies) {
      let meleeRange = 2;
      let damage = 10;
      
      if (enemy.isDemonKing) {
        meleeRange = 4;
        damage = 30;
      } else if (enemy.isMinion) {
        meleeRange = 1.5;
        damage = 5;
      } else if (enemy.isBoss) {
        meleeRange = 3;
        damage = 20;
      }
      
      if (camera.position.distanceTo(enemy.position) < meleeRange) {
        if (currentTime - lastDamageTime > 1000) {
          takeDamage(damage);
          lastDamageTime = currentTime;
        }
      }
    }
    
    renderer.render(scene, camera);
  }
  
  updateHealthUI(); 
  updateWeaponDisplay(); 
  updateEnemyCounter();
  updateMedikitCounter();
  animate();
  
  setTimeout(() => {
    loadingScreen.style.display = 'none';
    if (controls) {
      controls.lock();
    }
  }, 500);
  
  window.addEventListener('resize', () => { 
    camera.aspect = window.innerWidth / window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
  });
}
</script>
</body>
</html>
