<!DOCTYPE html>
<html>
<head>
  <title>Urban Combat TPS</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; font-family: sans-serif; }
    
    /* Menu Screen Styles */
    #menu-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('https://z-cdn-media.chatglm.cn/files/7091fe5f-1fa2-46f9-ac55-b8bb76b39660.png?auth_key=1872017979-36f4b8ed4bfe4082849cb5b2bc701b91-0-3fd47c606dfd5c32c635cb7ff530a692') no-repeat center center;
      background-size: cover;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 0.5s ease-out;
    }
    
    #menu-title {
      font-size: 48px;
      color: white;
      text-shadow: 3px 3px 0 #000;
      margin-bottom: 30px;
      font-family: 'Courier New', monospace;
      letter-spacing: 2px;
    }
    
    #start-button {
      padding: 15px 40px;
      font-size: 24px;
      background-color: rgba(255, 255, 255, 0.8);
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    #start-button:hover {
      background-color: white;
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }
    
    /* Game Screen Styles */
    #game-screen {
      display: none;
    }
    
    #crosshair { position: absolute; top: 50%; left: 50%; color: white; font-size: 30px; transform: translate(-50%, -50%); pointer-events: none; z-index: 10; }
    #instructions { position: absolute; top: 10px; width: 100%; text-align: center; color: white; z-index: 100; }
    #hud { position: absolute; bottom: 20px; left: 20px; color: white; z-index: 100; }
    #health-bar-container { width: 200px; height: 20px; border: 2px solid white; background-color: #555; }
    #health-bar { width: 100%; height: 100%; background-color: #4CAF50; }
    #weapon-display { margin-top: 10px; font-size: 20px; }
    #score-display { margin-top: 10px; font-size: 20px; color: gold; }
    #combo-display { margin-top: 5px; font-size: 16px; color: orange; }
    #game-over { position: absolute; top: 50%; left: 50%; color: red; font-size: 50px; font-weight: bold; transform: translate(-50%, -50%); display: none; z-index: 200; }
    #final-score { position: absolute; top: 60%; left: 50%; color: white; font-size: 30px; transform: translate(-50%, -50%); display: none; z-index: 200; }
    .hit-popup { position: absolute; color: yellow; font-size: 24px; font-weight: bold; pointer-events: none; animation: fadeOut 1s forwards; z-index: 150; }
    @keyframes fadeOut {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-30px); }
    }
  </style>
</head>
<body>

<!-- Menu Screen -->
<div id="menu-screen">
  <h1 id="menu-title">URBAN COMBAT</h1>
  <button id="start-button">CLICK TO PLAY</button>
</div>

<!-- Game Screen -->
<div id="game-screen">
  <div id="instructions">WASD to move, Mouse to look, Click to shoot</div>
  <div id="crosshair">+</div>
  <div id="hud">
    <div>Health</div>
    <div id="health-bar-container"><div id="health-bar"></div></div>
    <div id="weapon-display">Weapon: Pistol</div>
    <div id="score-display">Score: 0</div>
    <div id="combo-display">Combo: x1</div>
  </div>
  <div id="game-over">GAME OVER</div>
  <div id="final-score">Final Score: 0</div>
</div>

<script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

// --- MENU SCREEN LOGIC ---
const menuScreen = document.getElementById('menu-screen');
const gameScreen = document.getElementById('game-screen');
const startButton = document.getElementById('start-button');

startButton.addEventListener('click', () => {
  menuScreen.style.opacity = '0';
  setTimeout(() => {
    menuScreen.style.display = 'none';
    gameScreen.style.display = 'block';
    initGame();
  }, 500);
});

// --- GAME INITIALIZATION ---
function initGame() {
  // --- SCENE SETUP ---
  const scene = new THREE.Scene(); 
  scene.background = new THREE.Color(0x87ceeb); 
  scene.fog = new THREE.Fog(0x87ceeb, 20, 200);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); 
  camera.position.set(0, 2.5, 30);
  const renderer = new THREE.WebGLRenderer({ antialias: true }); 
  renderer.setSize(window.innerWidth, window.innerHeight); 
  renderer.shadowMap.enabled = true; 
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
  document.body.appendChild(renderer.domElement);

  // --- GUN MODEL ---
  function createGunModel() { 
    const gun = new THREE.Group(); 
    const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7, roughness: 0.3 }); 
    const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1), gunMaterial); 
    barrel.position.z = 0.5; 
    gun.add(barrel); 
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.25, 0.7), gunMaterial); 
    body.position.z = 0.1; 
    gun.add(body); 
    const grip = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.2), gunMaterial); 
    grip.position.set(0, -0.3, -0.1); 
    gun.add(grip); 
    return gun; 
  }

  // --- PLAYER MODEL & CONTROLS ---
  const playerModel = createPlayerModel(); 
  scene.add(playerModel);
  const controls = new PointerLockControls(camera, document.body);
  
  function createPlayerModel() { 
    const model = new THREE.Group(); 
    const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xfdbcb4 }); 
    const shirtMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff }); 
    const pantsMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 }); 
    const head = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), skinMaterial); 
    head.position.y = 2.5; 
    model.add(head); 
    const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.5), shirtMaterial); 
    body.position.y = 1.25; 
    model.add(body); 
    const armGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.3); 
    const leftArm = new THREE.Mesh(armGeometry, skinMaterial); 
    leftArm.position.set(-0.65, 1.25, 0); 
    model.add(leftArm); 
    const rightArm = new THREE.Mesh(armGeometry, skinMaterial); 
    rightArm.position.set(0.65, 1.25, 0); 
    model.add(rightArm); 
    const legGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4); 
    const leftLeg = new THREE.Mesh(legGeometry, pantsMaterial); 
    leftLeg.position.set(-0.25, 0, 0); 
    model.add(leftLeg); 
    const rightLeg = new THREE.Mesh(legGeometry, pantsMaterial); 
    rightLeg.position.set(0.25, 0, 0); 
    model.add(rightLeg); 
    const gun = createGunModel(); 
    gun.position.set(0, -0.4, 0.2); 
    rightArm.add(gun); 
    model.rightArm = rightArm; 
    model.traverse(child => { if (child instanceof THREE.Mesh) { child.castShadow = true; } }); 
    return model; 
  }

  // --- ENEMY MODEL ---
  function createEnemyModel() { 
    const model = new THREE.Group(); 
    const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 }); 
    const pantsMaterial = new THREE.MeshStandardMaterial({ color: 0x2F4F4F }); 
    const head = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), enemyMaterial); 
    head.position.y = 2.5; 
    model.add(head); 
    const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.5), enemyMaterial); 
    body.position.y = 1.25; 
    model.add(body); 
    const armGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.3); 
    const leftArm = new THREE.Mesh(armGeometry, enemyMaterial); 
    leftArm.position.set(-0.65, 1.25, 0); 
    model.add(leftArm); 
    const rightArm = new THREE.Mesh(armGeometry, enemyMaterial); 
    rightArm.position.set(0.65, 1.25, 0); 
    model.add(rightArm); 
    const legGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4); 
    const leftLeg = new THREE.Mesh(legGeometry, pantsMaterial); 
    leftLeg.position.set(-0.25, 0, 0); 
    model.add(leftLeg); 
    const rightLeg = new THREE.Mesh(legGeometry, pantsMaterial); 
    rightLeg.position.set(0.25, 0, 0); 
    model.add(rightLeg); 
    model.health = 100; 
    model.maxHealth = 100; 
    model.speed = 0.02; 
    model.fireRate = 2000; 
    model.lastShotTime = 0; 
    model.shootingRange = 25; 
    model.state = 'patrol'; 
    model.targetPosition = null; 
    model.lastStateChange = 0; 
    model.coverPosition = null; 
    model.traverse(child => { if (child instanceof THREE.Mesh) { child.castShadow = true; } }); 
    return model; 
  }

  // --- COLLISION SYSTEM ---
  const collisionBoxes = [];
  function addCollisionBox(minX, maxX, minZ, maxZ) {
    collisionBoxes.push({ minX, maxX, minZ, maxZ });
  }

  function checkCollision(x, z, radius = 0.5) {
    for (const box of collisionBoxes) {
      if (x + radius > box.minX && x - radius < box.maxX &&
          z + radius > box.minZ && z - radius < box.maxZ) {
        return true;
      }
    }
    return false;
  }

  // --- MAP GENERATOR WITH COLLISION ---
  function createBuilding(x, z, width, depth, height = 8, color = 0x808080) {
    const wallThickness = 0.5; 
    const wallMaterial = new THREE.MeshStandardMaterial({ color: color });
    const floor = new THREE.Mesh(new THREE.BoxGeometry(width, 0.1, depth), new THREE.MeshStandardMaterial({ color: 0x696969 })); 
    floor.position.set(x, 0.05, z); 
    floor.receiveShadow = true; 
    scene.add(floor);
    const roof = new THREE.Mesh(new THREE.BoxGeometry(width, 0.2, depth), new THREE.MeshStandardMaterial({ color: 0x4a4a4a })); 
    roof.position.set(x, height, z); 
    roof.castShadow = true; 
    roof.receiveShadow = true; 
    scene.add(roof);
    const frontWall = new THREE.Mesh(new THREE.BoxGeometry(width, height, wallThickness), wallMaterial); 
    frontWall.position.set(x, height / 2, z - depth / 2); 
    frontWall.castShadow = true; 
    scene.add(frontWall);
    const backWall = new THREE.Mesh(new THREE.BoxGeometry(width, height, wallThickness), wallMaterial); 
    backWall.position.set(x, height / 2, z + depth / 2); 
    backWall.castShadow = true; 
    scene.add(backWall);
    const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, height, depth), wallMaterial); 
    leftWall.position.set(x - width / 2, height / 2, z); 
    leftWall.castShadow = true; 
    scene.add(leftWall);
    const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, height, depth), wallMaterial); 
    rightWall.position.set(x + width / 2, height / 2, z); 
    rightWall.castShadow = true; 
    scene.add(rightWall);
    
    // Add collision box for this building
    addCollisionBox(x - width/2, x + width/2, z - depth/2, z + depth/2);
  }

  function createCover(x, z) {
    const cover = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 0.5), new THREE.MeshStandardMaterial({ color: 0x654321 }));
    cover.position.set(x, 0.5, z);
    cover.castShadow = true; 
    cover.receiveShadow = true;
    scene.add(cover);
    
    // Add collision box for cover
    addCollisionBox(x - 2, x + 2, z - 0.25, z + 0.25);
  }

  function generateMap() {
    // Central Compound
    createBuilding(0, 0, 20, 20, 10, 0xA0522D);
    createBuilding(25, 0, 15, 12, 8, 0x696969);
    createBuilding(-25, 0, 15, 12, 8, 0x696969);
    
    // North District
    createBuilding(0, -40, 12, 15, 7, 0x8B4513);
    createBuilding(20, -45, 10, 10, 6, 0x696969);
    createBuilding(-20, -45, 10, 10, 6, 0x696969);

    // South District
    createBuilding(0, 40, 18, 14, 8, 0xA0522D);
    createBuilding(30, 35, 12, 12, 7, 0x8B4513);
    createBuilding(-30, 35, 12, 12, 7, 0x8B4513);

    // East & West Outposts
    createBuilding(45, 10, 12, 12, 7, 0x8B4513);
    createBuilding(-45, 10, 12, 12, 7, 0x8B4513);

    // Add cover objects
    createCover(12, 0);
    createCover(-12, 0);
    createCover(0, 20);
    createCover(0, -20);
    createCover(30, 15);
    createCover(-30, 15);
  }

  // --- LIGHTING ---
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); 
  directionalLight.position.set(50, 100, 50); 
  directionalLight.castShadow = true; 
  directionalLight.shadow.camera.left = -100; 
  directionalLight.shadow.camera.right = 100; 
  directionalLight.shadow.camera.top = 100; 
  directionalLight.shadow.camera.bottom = -100; 
  scene.add(directionalLight);

  // --- WORLD ---
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.8 }));
  floor.rotation.x = -Math.PI / 2; 
  floor.receiveShadow = true; 
  scene.add(floor);

  generateMap();

  // --- SCORING SYSTEM ---
  let score = 0;
  let combo = 1;
  let lastKillTime = 0;
  const scoreDisplay = document.getElementById('score-display');
  const comboDisplay = document.getElementById('combo-display');
  const finalScoreDisplay = document.getElementById('final-score');

  function updateScore(points) {
    const currentTime = Date.now();
    if (currentTime - lastKillTime < 2000) {
      combo = Math.min(combo + 0.5, 5);
    } else {
      combo = 1;
    }
    lastKillTime = currentTime;
    
    score += Math.floor(points * combo);
    scoreDisplay.textContent = `Score: ${score}`;
    comboDisplay.textContent = `Combo: x${combo.toFixed(1)}`;
    
    // Show score popup
    showScorePopup(points);
  }

  function showScorePopup(points) {
    const popup = document.createElement('div');
    popup.className = 'hit-popup';
    popup.textContent = `+${Math.floor(points * combo)}`;
    popup.style.left = '50%';
    popup.style.top = '40%';
    document.body.appendChild(popup);
    
    setTimeout(() => {
      document.body.removeChild(popup);
    }, 1000);
  }

  // --- HIT EFFECT ---
  function createHitEffect(position) {
    // Create explosion effect
    const particleCount = 10;
    const particles = [];
    
    for (let i = 0; i < particleCount; i++) {
      const particle = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xff6600 })
      );
      particle.position.copy(position);
      
      const velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.5,
        Math.random() * 0.5,
        (Math.random() - 0.5) * 0.5
      );
      
      particle.velocity = velocity;
      particle.lifetime = 30; // frames
      
      scene.add(particle);
      particles.push(particle);
    }
    
    // Update particles in animation loop
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.position.add(particle.velocity);
        particle.velocity.y -= 0.01; // gravity
        particle.lifetime--;
        
        if (particle.lifetime <= 0) {
          scene.remove(particle);
          particles.splice(i, 1);
        }
      }
      
      if (particles.length > 0) {
        requestAnimationFrame(updateParticles);
      }
    }
    
    updateParticles();
  }

  // --- HEALTH, WEAPON, SHOOTING ---
  let playerHealth = 100; 
  const maxHealth = 100; 
  const healthBar = document.getElementById('health-bar'); 
  const gameOverScreen = document.getElementById('game-over');
  function updateHealthUI() { 
    const healthPercent = Math.max(0, playerHealth / maxHealth); 
    healthBar.style.width = (healthPercent * 100) + '%'; 
    if (healthPercent > 0.6) healthBar.style.backgroundColor = '#4CAF50'; 
    else if (healthPercent > 0.3) healthBar.style.backgroundColor = '#ff9800'; 
    else healthBar.style.backgroundColor = '#f44336'; 
  }
  function takeDamage(amount) { 
    playerHealth -= amount; 
    updateHealthUI(); 
    if (playerHealth <= 0) { 
      playerHealth = 0; 
      gameOverScreen.style.display = 'block'; 
      finalScoreDisplay.textContent = `Final Score: ${score}`; 
      finalScoreDisplay.style.display = 'block'; 
      controls.unlock(); 
      
      // Add restart button
      const restartButton = document.createElement('button');
      restartButton.textContent = 'RESTART';
      restartButton.style.position = 'absolute';
      restartButton.style.top = '70%';
      restartButton.style.left = '50%';
      restartButton.style.transform = 'translate(-50%, -50%)';
      restartButton.style.padding = '10px 20px';
      restartButton.style.fontSize = '20px';
      restartButton.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
      restartButton.style.border = 'none';
      restartButton.style.borderRadius = '5px';
      restartButton.style.cursor = 'pointer';
      restartButton.style.zIndex = '300';
      restartButton.addEventListener('click', () => {
        location.reload();
      });
      document.body.appendChild(restartButton);
    } 
  }
  const weapons = [
    { name: 'Pistol', fireRate: 300, bulletSpeed: 2, damage: 25, color: 0xffff00 }, 
    { name: 'Rifle', fireRate: 100, bulletSpeed: 4, damage: 15, color: 0xff0000 }, 
    { name: 'Shotgun', fireRate: 800, bulletSpeed: 3, damage: 50, color: 0x00ff00 }
  ];
  let currentWeaponIndex = 0; 
  let canShoot = true; 
  const weaponDisplay = document.getElementById('weapon-display');
  function updateWeaponDisplay() { 
    weaponDisplay.textContent = `Weapon: ${weapons[currentWeaponIndex].name}`; 
  }
  let bullets = []; 
  let enemies = [];
  function shoot() { 
    if (!canShoot) return; 
    const weapon = weapons[currentWeaponIndex]; 
    const pelletCount = weapon.name === 'Shotgun' ? 5 : 1; 
    const spreadAngle = 0.05; 
    for (let i = 0; i < pelletCount; i++) { 
      const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: weapon.color })); 
      bullet.position.copy(camera.position); 
      const direction = new THREE.Vector3(); 
      camera.getWorldDirection(direction); 
      if (pelletCount > 1) { 
        direction.x += (Math.random() - 0.5) * spreadAngle; 
        direction.y += (Math.random() - 0.5) * spreadAngle; 
        direction.normalize(); 
      } 
      bullet.velocity = direction.multiplyScalar(weapon.bulletSpeed); 
      bullet.damage = weapon.damage; 
      scene.add(bullet); 
      bullets.push(bullet); 
    } 
    canShoot = false; 
    setTimeout(() => { 
      canShoot = true; 
    }, weapon.fireRate); 
  }

  // --- ENEMY SPAWNING ---
  function createEnemy() {
    let spawnPosition;
    let attempts = 0;
    do {
      spawnPosition = {
        x: (Math.random() - 0.5) * 100,
        z: (Math.random() - 0.5) * 100
      };
      attempts++;
    } while (checkCollision(spawnPosition.x, spawnPosition.z) && attempts < 50);
    
    if (attempts < 50) {
      const enemy = createEnemyModel();
      enemy.position.set(spawnPosition.x, 1, spawnPosition.z);
      enemy.originalPosition = enemy.position.clone();
      scene.add(enemy);
      enemies.push(enemy);
    }
  }

  for (let i = 0; i < 10; i++) { 
    createEnemy(); 
  }
  let enemyBullets = [];

  // --- ENEMY AI BEHAVIOR ---
  function updateEnemyAI(enemy, currentTime) {
    const playerDistance = camera.position.distanceTo(enemy.position);
    
    // State machine
    switch(enemy.state) {
      case 'patrol':
        // Random patrol movement
        if (!enemy.targetPosition || enemy.position.distanceTo(enemy.targetPosition) < 2) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 10 + Math.random() * 10;
          enemy.targetPosition = enemy.originalPosition.clone().add(
            new THREE.Vector3(Math.cos(angle) * distance, 0, Math.sin(angle) * distance)
          );
        }
        
        // Move towards target position
        const patrolDirection = new THREE.Vector3();
        patrolDirection.subVectors(enemy.targetPosition, enemy.position);
        patrolDirection.y = 0;
        patrolDirection.normalize();
        
        const nextPos = enemy.position.clone().add(patrolDirection.multiplyScalar(enemy.speed));
        if (!checkCollision(nextPos.x, nextPos.z)) {
          enemy.position.add(patrolDirection.multiplyScalar(enemy.speed));
        }
        
        // Switch to combat if player is close
        if (playerDistance < 30) {
          enemy.state = 'combat';
          enemy.lastStateChange = currentTime;
        }
        break;
        
      case 'combat':
        // Combat behavior
        const direction = new THREE.Vector3();
        direction.subVectors(camera.position, enemy.position);
        direction.y = 0;
        direction.normalize();
        
        // Check if need to take cover
        if (enemy.health < enemy.maxHealth * 0.5 && Math.random() < 0.01) {
          enemy.state = 'cover';
          enemy.coverPosition = findCoverPosition(enemy);
          enemy.lastStateChange = currentTime;
        }
        
        // Move towards player but maintain distance
        if (playerDistance > 15) {
          const nextPos = enemy.position.clone().add(direction.multiplyScalar(enemy.speed * 1.5));
          if (!checkCollision(nextPos.x, nextPos.z)) {
            enemy.position.add(direction.multiplyScalar(enemy.speed * 1.5));
          }
        } else if (playerDistance < 10) {
          const nextPos = enemy.position.clone().add(direction.multiplyScalar(-enemy.speed));
          if (!checkCollision(nextPos.x, nextPos.z)) {
            enemy.position.add(direction.multiplyScalar(-enemy.speed));
          }
        }
        
        enemy.rotation.y = Math.atan2(direction.x, direction.z);
        
        // Shoot at player
        if (playerDistance < enemy.shootingRange && currentTime - enemy.lastShotTime > enemy.fireRate) {
          const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
          bullet.position.copy(enemy.position);
          bullet.position.y = 2.5;
          const bulletDirection = new THREE.Vector3();
          bulletDirection.subVectors(camera.position, enemy.position).normalize();
          bullet.velocity = bulletDirection.multiplyScalar(0.15);
          scene.add(bullet);
          enemyBullets.push(bullet);
          enemy.lastShotTime = currentTime;
        }
        
        // Return to patrol if player is far
        if (playerDistance > 50) {
          enemy.state = 'patrol';
          enemy.lastStateChange = currentTime;
        }
        break;
        
      case 'cover':
        // Move to cover
        if (enemy.coverPosition) {
          const coverDirection = new THREE.Vector3();
          coverDirection.subVectors(enemy.coverPosition, enemy.position);
          coverDirection.y = 0;
          coverDirection.normalize();
          
          const nextPos = enemy.position.clone().add(coverDirection.multiplyScalar(enemy.speed * 2));
          if (!checkCollision(nextPos.x, nextPos.z)) {
            enemy.position.add(coverDirection.multiplyScalar(enemy.speed * 2));
          }
          
          if (enemy.position.distanceTo(enemy.coverPosition) < 2) {
            enemy.state = 'combat';
            enemy.lastStateChange = currentTime;
          }
        }
        break;
    }
  }

  function findCoverPosition(enemy) {
    // Find nearby cover position
    const coverPositions = [
      { x: enemy.position.x + 10, z: enemy.position.z },
      { x: enemy.position.x - 10, z: enemy.position.z },
      { x: enemy.position.x, z: enemy.position.z + 10 },
      { x: enemy.position.x, z: enemy.position.z - 10 }
    ];
    
    for (const pos of coverPositions) {
      if (!checkCollision(pos.x, pos.z)) {
        return new THREE.Vector3(pos.x, 0, pos.z);
      }
    }
    return enemy.originalPosition.clone();
  }

  // --- EVENT LISTENERS ---
  document.getElementById('instructions').addEventListener('click', () => { 
    playerHealth = maxHealth; 
    score = 0;
    combo = 1;
    updateHealthUI(); 
    updateScore(0);
    gameOverScreen.style.display = 'none';
    finalScoreDisplay.style.display = 'none';
    controls.lock(); 
  });
  document.addEventListener('mousedown', (event) => { if (event.button === 0 && controls.isLocked) { shoot(); } });
  document.addEventListener('keydown', (e) => { 
    if (e.code === 'Digit1') { currentWeaponIndex = 0; updateWeaponDisplay(); } 
    if (e.code === 'Digit2') { currentWeaponIndex = 1; updateWeaponDisplay(); } 
    if (e.code === 'Digit3') { currentWeaponIndex = 2; updateWeaponDisplay(); } 
  });
  const keys = {}; 
  document.addEventListener("keydown", e => keys[e.code] = true); 
  document.addEventListener("keyup", e => keys[e.code] = false);

  // --- MOVEMENT & ANIMATION LOOP ---
  const moveSpeed = 0.3; 
  let lastDamageTime = 0;
  function animate() {
    requestAnimationFrame(animate);
    if (controls.isLocked) {
      const moveVector = new THREE.Vector3(); 
      const forward = new THREE.Vector3(); 
      const right = new THREE.Vector3();
      camera.getWorldDirection(forward); 
      forward.y = 0; 
      forward.normalize();
      right.crossVectors(forward, camera.up);
      if (keys["KeyW"]) moveVector.add(forward); 
      if (keys["KeyS"]) moveVector.sub(forward); 
      if (keys["KeyA"]) moveVector.sub(right); 
      if (keys["KeyD"]) moveVector.add(right);
      
      // Apply movement with collision detection
      if (moveVector.length() > 0) {
        moveVector.normalize();
        const nextPos = camera.position.clone().add(moveVector.multiplyScalar(moveSpeed));
        
        // Check collision before moving
        if (!checkCollision(nextPos.x, nextPos.z)) {
          camera.position.copy(nextPos);
        }
      }
      
      const modelOffset = new THREE.Vector3(0, -2.5, 2);
      const desiredModelPos = camera.position.clone().add(modelOffset.applyQuaternion(camera.quaternion));
      playerModel.position.lerp(desiredModelPos, 0.2);
      playerModel.rotation.y = camera.rotation.y;
      playerModel.rightArm.rotation.x = camera.rotation.x;
      
      const currentTime = Date.now();
      
      // Update enemy AI
      for (const enemy of enemies) {
        updateEnemyAI(enemy, currentTime);
      }
      
      // Spawn new enemies periodically
      if (enemies.length < 15 && Math.random() < 0.005) {
        createEnemy();
      }
    }
    
    // Update bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const bullet = bullets[i];
      bullet.position.add(bullet.velocity);
      
      // Check bullet-enemy collision
      for (let j = enemies.length - 1; j >= 0; j--) {
        const enemy = enemies[j];
        if (bullet.position.distanceTo(enemy.position) < 1.5) {
          // Create hit effect
          createHitEffect(enemy.position);
          
          // Enemy dies immediately on hit
          scene.remove(enemy);
          enemies.splice(j, 1);
          
          // Update score
          updateScore(100);
          
          // Remove bullet
          scene.remove(bullet);
          bullets.splice(i, 1);
          break;
        }
      }
      
      // Remove bullets that are too far
      if (bullet && bullet.position.length() > 100) {
        scene.remove(bullet);
        bullets.splice(i, 1);
      }
    }
    
    // Update enemy bullets
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const bullet = enemyBullets[i];
      bullet.position.add(bullet.velocity);
      
      if (bullet.position.distanceTo(camera.position) < 1) {
        takeDamage(10);
        scene.remove(bullet);
        enemyBullets.splice(i, 1);
      } else if (bullet.position.length() > 100) {
        scene.remove(bullet);
        enemyBullets.splice(i, 1);
      }
    }
    
    // Melee damage
    const currentTime = Date.now();
    for (const enemy of enemies) {
      if (camera.position.distanceTo(enemy.position) < 2) {
        if (currentTime - lastDamageTime > 1000) {
          takeDamage(10);
          lastDamageTime = currentTime;
        }
      }
    }
    
    renderer.render(scene, camera);
  }
  
  updateHealthUI(); 
  updateWeaponDisplay(); 
  animate();
  
  // Lock controls when game starts
  setTimeout(() => {
    controls.lock();
  }, 1000);
  
  window.addEventListener('resize', () => { 
    camera.aspect = window.innerWidth / window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
  });
}
</script>
</body>
</html>